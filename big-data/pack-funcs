#!/bin/bash
set -e
usage() {
  echo "Usage: initializeVariables {product_name}"
  echo "Usage: getSourcesToRelevantDirectories {product_name}"
  echo "Usage: generateDebianPackage {product_name}"
  echo "Example: generateDebianPackage hadoop"
  exit 1
}


initializeVariables() {
  if [[ $1 == "" ]]; then
    usage
  fi
  productName=$1
  productNameUppercase="$(tr '[:lower:]' '[:upper:]' <<< ${productName:0:1})${productName:1}"
  BASE=/var/lib/jenkins/jobs/master.bigdata.$productName/$productNameUppercase
  SOURCE="/var/lib/jenkins/jobs/master.get_branch_repo/workspace/big-data/$productName/$productName"
  TARGET="/var/lib/jenkins/Automation/Bigdata/$productName"

  pushd $BASE
  if ls *.deb ; then
    rm  *.deb
  fi
  fileName=`ls | grep subutai | awk '{print $1}' | head -1`
  if [[ $fileName == "" ]]; then
    fileName="subutai-$productName"
    mkdir -p $fileName
  fi
  popd
}


getSourcesToRelevantDirectories() {
  initializeVariables $1
  pushd $BASE
  # Clear the previous contents of the directory
  if [ -d $BASE/$fileName ]; then
    rm -r $BASE/$fileName
  fi
  mkdir $BASE/$fileName
  # Copy the sources that are pulled from the version control system
  cp -a -r $SOURCE/* $BASE/$fileName
  popd
}

#check version of given bigdata product 
checkPackageVersion() {
  checkVersion $productName "bdproduct"
}


generateDebianPackage() {
  updatePackageContent $1
  pushd $BASE
  generateConfFiles $1
  generateMD5Sum $1
  dpkg-deb -z8 -Zgzip --build $packageName/
  cp $packageName".deb" $TARGET/
  popd
}


generateDebianPackageWithoutMD5() {
  updatePackageContent $1
  pushd $BASE
  dpkg-deb -z8 -Zgzip --build $packageName/
  cp $packageName".deb" $TARGET/
  popd
}


updatePackageContent() {
  initializeVariables $1
  pushd $BASE

  lineNumberVersion=$(sed -n '/Version:/=' $fileName/DEBIAN/control)
  lineNumberPackage=$(sed -n '/Package:/=' $fileName/DEBIAN/control)
  lineVersion=$(sed $lineNumberVersion!d $fileName/DEBIAN/control)
  linePackage=$(sed $lineNumberPackage!d $fileName/DEBIAN/control)

  version=$(echo $lineVersion | awk -F":" '{split($2,a," ");print a[1]}')
  package=$(echo $linePackage | awk -F":" '{split($2,a," ");print a[1]}')

  versionFirst=$(echo $version | awk -F"." '{print $1}')
  versionSecond=$(echo $version | awk -F"." '{print $2}')
  versionThird=$(echo $version | awk -F"." '{print $3}')

  # Increment the least significant version by 1
  #updatedVersion=$(echo `expr $versionThird + 1`)
  updatedVersion=$versionThird

  updatedRelease=$versionFirst.$versionSecond.$updatedVersion
  replaceVersion="Version: $updatedRelease"

  arch=$(getArchitecture)
  packageName="$package"_"$updatedRelease"_"$arch"

  # Update control file with the incremented version
  sed -i $fileName/DEBIAN/control -e $lineNumberVersion's!.*!'"$replaceVersion"'!'

  if [ "$fileName" != "$packageName" ] ;then
    mv $fileName $packageName
  fi

  find ./$packageName -name "*~" -print0 | xargs -0 rm -rf
  if [ -f "$packageName/DEBIAN/md5sums" ]; then
    rm $packageName/DEBIAN/md5sums
  fi
  popd
}


generateConfFiles() {
  echo "Generating conf files"
  local product_name=$1
  initializeVariables $product_name
  local confFile="$packageName/DEBIAN/conffile"
  pushd $BASE
  local FILES="$packageName/etc/$product_name/*"
  echo "FILES: $FILES"
  if [ ! "$(ls -A $package_name/etc/$product_name)" ]; then
    echo "No configuration file found for $product_name. Not generating conffile.."
    return
  fi
  > $confFile
  for f in $FILES
  do
    local confFilePath=$(echo $f | awk -F"etc/" '{print $2}')
    echo "Processing /etc/$confFilePath"
    echo "/etc/$confFilePath" >> $confFile
  done
  popd
}


generateMD5Sum() {
  initializeVariables $1
  pushd $BASE
  md5sum `find ./$packageName -type f | awk '/.\//{ print substr($0, 3) }'` >> $packageName/DEBIAN/md5sums
  popd
}


getArchitecture() {
  #TODO get the actual architecture from the debian packages control file
  echo "all"
}

#generate repo wrapper package for given debian package
generateRepoPackage() {
  #check initial productName is not empty
  if [[ $1 == "" ]]; then
    usage
  fi
  
  #Basic path definitions
  productName=$1  

  #it's template package operation
  if [[ $productName == *"template"* ]]; then
    BASE=/var/lib/jenkins/Automation/Automation_ISO/Packages/$productName
    SOURCE="/var/lib/jenkins/jobs/master.get_branch_repo/workspace/big-data/$productName/$productName"
    TARGET="/var/lib/jenkins/Automation/Bigdata/$productName"
    PACK="/var/lib/jenkins/Automation/Automation_ISO/mgmt-repo/template-repo-package/"
    ISOPATH="/var/lib/jenkins/Automation/Automation_ISO/work/custom-iso/pool/extras/"
  else
    productNameUppercase="$(tr '[:lower:]' '[:upper:]' <<< ${productName:0:1})${productName:1}"
    BASE=/var/lib/jenkins/jobs/master.bigdata.$productName/$productNameUppercase
    SOURCE="/var/lib/jenkins/jobs/master.get_branch_repo/workspace/big-data/$productName/$productName"
    TARGET="/var/lib/jenkins/Automation/Bigdata/$productName"
    PACK="/var/lib/jenkins/Automation/Automation_ISO/mgmt-repo/template-repo-package/"
    ISOPATH="/var/lib/jenkins/Automation/Automation_ISO/work/custom-iso/pool/extras/"
  fi

  pushd $BASE

  #get latest package from ISOPATH to remove it
  removedPackage=`ls -lt $ISOPATH | grep "subutai-repo-$productName" | awk '{ print $9 }' | grep .deb | head -1`
  echo "removedPackageName: $removedPackage" 
  if [ "$removedPackage" != "" ]; then
    rm $ISOPATH/$removedPackage
  fi

  #get package full name, for example:subutai-hadoop_1.0.12_all.deb
  currentPackage=`ls -lt $TARGET | awk '{ print $9 }' | grep .deb | head -1` 
  echo "CurrentPackageName: $currentPackage"

  #delete repo package: subutai-repo-hadoop_1.0.12_all.deb
  if [ -f "$ISOPATH/subutai-repo-$currentPackage" ]; then
      rm $ISOPATH/subutai-repo-$currentPackage 
  fi
  
  if [[ "$currentPackage" == *"template"* ]]; then
     productVersion=$2
     shortCurrentPackage="$productName""_""$productVersion""_amd64"
     purePackageName=$productName
     echo "shortCurrentPackage: $shortCurrentPackage"
  
  elif [[ "$currentPackage" == *"subutai"* ]]; then
     shortCurrentPackage=`echo "$currentPackage" | awk '{print substr($1,9); }'  | awk '{print substr($0, 0, length($0)-4)}'`
     echo "shortCurrentPackage: $shortCurrentPackage"
     purePackageName=`echo $shortCurrentPackage | awk -F "." '{print $1}' | awk '{print substr($0, 0, length($0)-2)}'`
     echo "purePackageName: $purePackageName"
  else
     echo "pure packagename cannot be resolved."
     exit 1
  fi

  #check purePackageName is empty or not
  if [ -z $purePackageName ] || [ "x$purePackageName" == "x" ]; then
     echo "Pure package name is empty. Aborting..."
     exit 1
  fi

  templateName="temp"

  #check temp folder does exist or not
  if [ -d "$templateName" ]; then
    rm -rf "$BASE/$templateName"
  fi
  cp -a $PACK $BASE/$templateName

  sed -i "s/template/subutai-repo-$purePackageName/g" $BASE/$templateName/DEBIAN/control
  cp $currentPackage $BASE/$templateName/repo/ksks/amd64/trusty/
  mv $BASE/$templateName/ $BASE/subutai-repo-$shortCurrentPackage
  
  CURRENTPACK=$BASE/subutai-repo-$shortCurrentPackage
  echo "CURRENTPACK: $CURRENTPACK"

  dpkg-deb --build $CURRENTPACK
  mv $BASE/subutai-repo-"$shortCurrentPackage".deb $ISOPATH
  rm -rf $BASE/subutai-repo-$shortCurrentPackage
  rm -rf $BASE/$templateName

  echo "Repo wrapper package Successfully created."

  popd
}

#get subutai template version using productVersion reference
getTemplateVersion() {
  productName=$1
  productVersion=$2

  CONTROL="/var/lib/jenkins/jobs/master.get_branch_repo_all_plugins/workspace/$productName-plugin/debian/changelog"

  local version_new=`cat $CONTROL | grep $productName-subutai-plugin | awk -F" " '{print $2}'`
  version_new=`echo ${version_new//[()]/}`
  productVersion=$version_new
}

#check subutai tempalte version status
checkTemplatePackageVersion() {
  checkVersion $productName "template"
}


#check version of package based on type
checkVersion() {
  mode=$2
  echo "MODE: $mode"
  if [ "$mode" = "template" ]; then

    CONTROL="/var/lib/jenkins/jobs/master.get_branch_repo_all_plugins/workspace/$productName-plugin/debian/control"
    TARGET="/var/lib/jenkins/Automation/Automation_ISO/Packages/$productName-subutai-template"
  
    version_new=`cat $CONTROL | grep "Pre-Depends:" | awk -F"(" '{print $2}'| awk -F")" '{print $1}'`
    version_new=$(echo $version_new | awk -F" " '{print $2}')
    echo "Version= $version_new"
    
  elif [ "$mode" = "n2n" ]; then

    CONTROL="/var/lib/jenkins/jobs/master.get_repo_github/workspace/subutai_n2n/debian/changelog"
    TARGET="/var/lib/jenkins/Automation/Automation_ISO/work/custom-iso/pool/extras"

    version_new=`cat $CONTROL | grep "subutai-n2n" | awk -F" " '{print $2}'`
    version_new=`echo ${version_new//[()]/}`
    echo "Version= $version_new"

  elif [ "$mode" = "bdproduct" ]; then

    CONTROL="/var/lib/jenkins/jobs/master.get_branch_repo/workspace/big-data/$productName/$productName/DEBIAN/control"
    TARGET="/var/lib/jenkins/Automation/Bigdata/$productName"

    lineNumberVersion=$(sed -n '/Version:/=' $CONTROL)
    lineVersion=$(sed $lineNumberVersion!d $CONTROL)
    version_new=$(echo $lineVersion | awk -F":" '{split($2,a," ");print a[1]}')

  fi

  versionFirst_new=$(echo $version_new | awk -F"." '{print $1}')
  versionSecond_new=$(echo $version_new | awk -F"." '{print $2}')
  version_tmp=$(echo $version_new | awk -F"." '{print $3}')
  versionThird_new=$(echo $version_tmp | awk -F"-" '{print $1}')
  patch_new=$(echo $version_tmp | awk -F"-" '{print $2}')

  deb_name=`ls -lt $TARGET | awk '{ print $9 }' | grep .deb | head -1`
  version_prev=$(echo $deb_name | awk -F"_" '{print $2}')
  versionFirst_prev=$(echo $version_prev | awk -F"." '{print $1}')
  versionSecond_prev=$(echo $version_prev | awk -F"." '{print $2}')

  version_tmp_prev=$(echo $version_prev | awk -F"." '{print $3}')
  versionThird_prev=$(echo $version_tmp_prev | awk -F"-" '{print $1}')
  patch_prev=$(echo $version_tmp_prev | awk -F"-" '{print $2}')
 

  if [ -z $patch_prev ]; then
    patch_prev=0
  fi
  
  if [ -z $patch_new ]; then
    patch_new=0
  fi

  echo "version in control:$version_new current version:$version_prev "

  if [ $versionFirst_new -lt $versionFirst_prev ]; then
    echo "major: current version is greater than the version in control file. Version in control file:$version_new, current version:$version_prev"
    exit 0;
  elif [ $versionFirst_new -eq $versionFirst_prev ]; then
     if [ $versionSecond_new -lt $versionSecond_prev ]; then
        echo "minor: current version is greater than the version in control file. Version in control file:$version_new, current version:$version_prev"
        exit 0;
     elif [ $versionSecond_new -eq $versionSecond_prev ]; then
        if [ $versionThird_new -lt $versionThird_prev ]; then
            echo "micro: current version is greater than the version in control file. Version in control file:$version_new, current version:$version_prev"
            exit 0;
        elif [ $versionThird_new -eq $versionThird_prev ]; then
          if [ $patch_new -lt $patch_prev  ]; then
               echo "patch: current version is greater than the version in control file. Version in control file:$version_new, current version:$version_prev"
                         exit 0;
          elif [ $patch_new -eq $patch_prev  ]; then
               echo "patch: current version is equal to the version in control file. Version in control file:$version_new, current version:$version_prev"
                         exit 0;
          fi
        fi
     fi
  fi
}


#remove a debian package from jenkins peer
#parameters $1: package name with absolute path $2: jenkins ssh ip address with username  
removePackagePeerSync() {
  echo "Remove Operation is starting.."
  removePackageName=$1
  echo "RemovePackageName= "$removePackageName

  if [ ! -z "$removePackageName" ]; then
    #removing missing or changed packages in the list
    echo "Removing $removePackageName from $2"
    ssh $2 "rm $removePackageName"
  fi
}

#parameters $1: ip of management $2: dependency list seperated by `,`
setRepoOnJenkinsPeer() {
  #Defining absolute
  mgmt_ip_address="root@$1"
  path_to_repo="/repo/ksks/amd64/trusty/"
  dependencies=""

  echo "mgmt ip: $mgmt_ip_address"
  depList=$(echo $2 | awk -F"\"" '{print $2}')
  echo "deplist=$depList"

  #for each dependency do the following
  IFS=',' read -ra template_name <<< "$depList"
  for name in "${template_name[@]}"; do		
    echo "***********************working on $name************************"
    target_template_name=$(echo $name | awk -F"-" '{print $2}')
    dependencies="$dependencies amd64/trusty/$name*.deb"	
    # echoes example: template name subutai-cassandra, target template name cassandra
    echo "template name $name"
    echo "target template name $target_template_name"
	 
    #get the name of latest debian on jenkins
    pack_path_jenkins="/var/lib/jenkins/Automation/Bigdata/$target_template_name"
    deb_name=`ls -lt $pack_path_jenkins | grep "subutai-$target_template_name" | awk '{ print $9 }' | grep .deb  | head -1`
    echo "deb name: $deb_name"

    #get the name of latest debian on jenkins peer
    latestPack=`ssh $mgmt_ip_address "ls -t $path_to_repo | grep subutai-$target_template_name | grep .deb | head -1"`

    echo "latest pack: $latestPack"
	
    #remove the latest debian package from jenkins peer
    fullPathOfPckg=$path_to_repo$latestPack
    removePackagePeerSync $fullPathOfPckg $mgmt_ip_address
    #copy the latest debian packagefrom jenkins to jenkins peer
    scp $pack_path_jenkins/$deb_name $mgmt_ip_address:$path_to_repo
    echo "copying package from $pack_path_jenkins/$deb_name to $mgmt_ip_address:$path_to_repo"
  done
  
  echo "************************dependencies are finished****************************"
	
  #do reprepro
  echo " start reprepro for $dependencies"
  ssh $mgmt_ip_address "cd /repo/ksks; reprepro includedeb trusty $dependencies"
  echo "reprepro finished."
  exit 0
}


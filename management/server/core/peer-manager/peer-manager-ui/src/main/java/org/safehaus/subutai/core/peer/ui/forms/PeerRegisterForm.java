package org.safehaus.subutai.core.peer.ui.forms;


import java.security.KeyStore;
import java.util.List;
import java.util.UUID;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.safehaus.subutai.common.peer.PeerException;
import org.safehaus.subutai.common.peer.PeerInfo;
import org.safehaus.subutai.common.peer.PeerStatus;
import org.safehaus.subutai.common.security.crypto.keystore.KeyStoreData;
import org.safehaus.subutai.common.security.crypto.keystore.KeyStoreManager;
import org.safehaus.subutai.common.settings.ChannelSettings;
import org.safehaus.subutai.common.settings.SecuritySettings;
import org.safehaus.subutai.common.util.JsonUtil;
import org.safehaus.subutai.common.util.RestUtil;
import org.safehaus.subutai.core.peer.ui.PeerManagerPortalModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cxf.jaxrs.client.WebClient;
import org.apache.cxf.jaxrs.ext.form.Form;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Property;
import com.vaadin.ui.AbsoluteLayout;
import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.Table;
import com.vaadin.ui.TextField;


/**
 * Registration process should be handled in save manner so no middleware attacks occur. In order to get there peers
 * need to exchange with public keys. This will create ssl layer by encrypting all traffic passing through their
 * connection. So first initial handshake will be one direction, to pass keys through encrypted channel and register
 * them in peers' trust stores. These newly saved keys will be used further for safe communication, with bidirectional
 * authentication.
 *
 *
 * TODO here still exists some issues concerned via registration/reject/approve requests. Some of them must pass through
 * secure channel such as unregister process. Which already must be in bidirectional auth completed stage.
 */
public class PeerRegisterForm extends CustomComponent
{

    private static final Logger LOG = LoggerFactory.getLogger( PeerRegisterForm.class.getName() );
    public final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    @AutoGenerated
    private AbsoluteLayout mainLayout;
    @AutoGenerated
    private Table peersTable;
    @AutoGenerated
    private Button showPeersButton;
    @AutoGenerated
    private Button registerRequestButton;
    @AutoGenerated
    private TextField ipTextField;

    private PeerManagerPortalModule module;


    /**
     * The constructor should first build the main layout, set the composition root and then do any custom
     * initialization. <p/> The constructor will not be automatically regenerated by the visual editor.
     */
    public PeerRegisterForm( final PeerManagerPortalModule module )
    {
        buildMainLayout();
        setCompositionRoot( mainLayout );

        this.module = module;

        showPeersButton.click();
    }


    @AutoGenerated
    private AbsoluteLayout buildMainLayout()
    {
        // common part: create layout
        mainLayout = new AbsoluteLayout();
        mainLayout.setImmediate( false );
        mainLayout.setWidth( "100%" );
        mainLayout.setHeight( "100%" );

        // top-level component properties
        setWidth( "100.0%" );
        setHeight( "100.0%" );

        // peerRegisterLayout
        final AbsoluteLayout peerRegisterLayout = buildAbsoluteLayout_2();
        mainLayout.addComponent( peerRegisterLayout, "top:20.0px;right:0.0px;bottom:-20.0px;left:0.0px;" );

        return mainLayout;
    }


    @AutoGenerated
    private AbsoluteLayout buildAbsoluteLayout_2()
    {

        // common part: create layout
        AbsoluteLayout absoluteLayout = new AbsoluteLayout();
        absoluteLayout.setImmediate( false );
        absoluteLayout.setWidth( "100.0%" );
        absoluteLayout.setHeight( "100.0%" );

        // peerRegistration
        final Label peerRegistration = new Label();
        peerRegistration.setImmediate( false );
        peerRegistration.setWidth( "-1px" );
        peerRegistration.setHeight( "-1px" );
        peerRegistration.setValue( "Peer registration" );
        absoluteLayout.addComponent( peerRegistration, "top:0.0px;left:20.0px;" );

        // IP
        final Label IP = new Label();
        IP.setImmediate( false );
        IP.setWidth( "-1px" );
        IP.setHeight( "-1px" );
        IP.setValue( "IP" );
        absoluteLayout.addComponent( IP, "top:36.0px;left:20.0px;" );

        // ipTextField
        ipTextField = new TextField();
        ipTextField.setImmediate( false );
        ipTextField.setWidth( "-1px" );
        ipTextField.setHeight( "-1px" );
        ipTextField.setMaxLength( 15 );
        absoluteLayout.addComponent( ipTextField, "top:36.0px;left:150.0px;" );

        // registerRequestButton
        registerRequestButton = createRegisterButton();
        absoluteLayout.addComponent( registerRequestButton, "top:160.0px;left:20.0px;" );
        registerRequestButton = createRegisterButton();

        // showPeersButton
        showPeersButton = createShowPeersButton();
        absoluteLayout.addComponent( showPeersButton, "top:234.0px;left:20.0px;" );

        // peersTable
        peersTable = new Table();
        peersTable.setCaption( "Peers" );
        peersTable.setImmediate( false );
        peersTable.setWidth( "1000px" );
        peersTable.setHeight( "283px" );
        absoluteLayout.addComponent( peersTable, "top:294.0px;left:20.0px;" );

        return absoluteLayout;
    }


    private Button createShowPeersButton()
    {
        showPeersButton = new Button();
        showPeersButton.setCaption( "Show peers" );
        showPeersButton.setImmediate( false );
        showPeersButton.setWidth( "-1px" );
        showPeersButton.setHeight( "-1px" );

        showPeersButton.addClickListener( new Button.ClickListener()
        {
            @Override
            public void buttonClick( final Button.ClickEvent clickEvent )
            {
                populateData();
                peersTable.refreshRowCache();
            }
        } );

        return showPeersButton;
    }


    private void populateData()
    {
        List<PeerInfo> peers = module.getPeerManager().peers();
        peersTable.removeAllItems();
        peersTable.addContainerProperty( "ID", UUID.class, null );
        peersTable.addContainerProperty( "Name", String.class, null );
        peersTable.addContainerProperty( "IP", String.class, null );
        peersTable.addContainerProperty( "Status", PeerStatus.class, null );
        peersTable.addContainerProperty( "ActionsAdvanced", PeerManageActionsComponent.class, null );

        for ( final PeerInfo peer : peers )
        {
            if ( peer == null || peer.getStatus() == null )
            {
                continue;
            }
            /**
             * According to peer status perform sufficient action
             */
            PeerManageActionsComponent.PeerManagerActionsListener listener =
                    new PeerManageActionsComponent.PeerManagerActionsListener()

                    {
                        @Override
                        public void OnPositiveButtonTrigger( final PeerInfo peer )
                        {
                            switch ( peer.getStatus() )
                            {
                                case REQUESTED:
                                    PeerInfo selfPeer = module.getPeerManager().getLocalPeerInfo();
                                    approvePeerRegistration( selfPeer, peer );
                                    break;
                                case REGISTERED:
                                    //TODO In further devs plan to support several states
                                    break;
                                case BLOCKED:
                                    break;
                            }
                        }


                        @Override
                        public void OnNegativeButtonTrigger( final PeerInfo peer )
                        {
                            //TODO perform different actions on peer rejected request
                            PeerInfo selfPeer = module.getPeerManager().getLocalPeerInfo();
                            switch ( peer.getStatus() )
                            {
                                case REJECTED:
                                    removeMeFromRemote( selfPeer, peer );
                                    break;
                                case BLOCKED:
                                case BLOCKED_PEER:
                                case REQUESTED:
                                case REQUEST_SENT:
                                    rejectPeerRegistration( selfPeer, peer );
                                    break;
                                case APPROVED:
                                    unregisterMeFromRemote( selfPeer, peer );
                                    break;
                            }
                        }
                    };
            PeerManageActionsComponent component = new PeerManageActionsComponent( module, peer, listener );
            peersTable
                    .addItem( new Object[] { peer.getId(), peer.getName(), peer.getIp(), peer.getStatus(), component },
                            peer.getId() );
        }
    }


    /**
     * Send peer to register on remote peer. To construct secure connection. For now initializer peer doesn't send its
     * px2 (public key requiring bidirectional authentication).
     *
     * @param peerToRegister - initializer peer info for registration process
     * @param ip - target peer ip address
     */
    private void registerMeToRemote( final PeerInfo peerToRegister, final String ip )
    {
        new Thread( new Runnable()
        {
            @Override
            public void run()
            {
                String baseUrl = String.format( "https://%s:%s/cxf", ip, ChannelSettings.SECURE_PORT_X1 );
                WebClient client = RestUtil.createTrustedWebClient( baseUrl );//WebClient.create( baseUrl );
                client.type( MediaType.MULTIPART_FORM_DATA ).accept( MediaType.APPLICATION_JSON );
                Form form = new Form();
                form.set( "peer", GSON.toJson( peerToRegister ) );

                try
                {
                    Response response = client.path( "peer/register" ).form( form );
                    if ( response.getStatus() == Response.Status.OK.getStatusCode() )
                    {
                        Notification.show( String.format( "Request sent to %s!", ip ) );
                        String responseString = response.readEntity( String.class );
                        LOG.info( response.toString() );
                        PeerInfo remotePeerInfo = JsonUtil.from( responseString, new TypeToken<PeerInfo>()
                        {
                        }.getType() );
                        if ( remotePeerInfo != null )
                        {
                            remotePeerInfo.setStatus( PeerStatus.REQUEST_SENT );
                            try
                            {
                                module.getPeerManager().register( remotePeerInfo );
                            }
                            catch ( PeerException e )
                            {
                                Notification.show( "Couldn't register peer. " + e.getMessage(),
                                        Notification.Type.WARNING_MESSAGE );
                                LOG.error( "Couldn't register peer", e );
                            }
                        }
                    }
                    else
                    {
                        LOG.warn( "Response for registering peer: " + response.toString() );
                    }
                }
                catch ( Exception e )
                {
                    Notification.show( "Please check peer address for correctness", Notification.Type.WARNING_MESSAGE );
                    LOG.error( "error sending request", e );
                }
            }
        } ).start();
    }


    private void unregisterMeFromRemote( final PeerInfo peerToUnregister, final PeerInfo remotePeerInfo )
    {
        new Thread( new Runnable()
        {
            @Override
            public void run()
            {
                String baseUrl =
                        String.format( "https://%s:%s/cxf", remotePeerInfo.getIp(), ChannelSettings.SECURE_PORT_X2 );
                WebClient client = RestUtil.createTrustedWebClientWithAuth( baseUrl,
                        SecuritySettings.KEYSTORE_PX2_ROOT_ALIAS );// WebClient.create( baseUrl );
                try
                {
                    Response response = client.path( "peer/unregister" ).type( MediaType.APPLICATION_JSON )
                                              .accept( MediaType.APPLICATION_JSON )
                                              .query( "peerId", GSON.toJson( peerToUnregister.getId().toString() ) )
                                              .delete();
                    if ( response.getStatus() == Response.Status.OK.getStatusCode() )
                    {
                        LOG.info( response.toString() );
                        Notification.show( String.format( "Request sent to %s!", remotePeerInfo.getName() ) );
                        //************ Delete Trust SSL Cert **************************************
                        KeyStore keyStore;
                        KeyStoreData keyStoreData;
                        KeyStoreManager keyStoreManager;

                        keyStoreData = new KeyStoreData();
                        keyStoreData.setupTrustStorePx2();
                        keyStoreData.setAlias( remotePeerInfo.getId().toString() );

                        keyStoreManager = new KeyStoreManager();
                        keyStore = keyStoreManager.load( keyStoreData );

                        keyStoreManager.deleteEntry( keyStore, keyStoreData );
                        //***********************************************************************

                        module.getSslContextFactory().reloadTrustStore();
                        //            new Thread( new RestartCoreServlet() ).start();


                        module.getPeerManager().unregister( remotePeerInfo.getId().toString() );

                        peersTable.removeItem( remotePeerInfo.getId() );
                    }
                    else
                    {
                        LOG.warn( "Failed to unregister remote peer " + String.valueOf( response.getStatus() ) );
                        Notification.show( "Failed to unregister remote peer " + String.valueOf( response.getStatus() ),
                                Notification.Type.WARNING_MESSAGE );
                    }
                }
                catch ( PeerException e )
                {
                    LOG.error( "Error in unregister peer", e );
                }
                catch ( Exception e )
                {
                    LOG.error( "Error sending unregister request to remote peer.", e );
                    Notification.show( "Error sending unregister request to remote peer.",
                            Notification.Type.WARNING_MESSAGE );
                }
            }
        } ).start();
    }


    private void removeMeFromRemote( final PeerInfo peerToUnregister, final PeerInfo remotePeerInfo )
    {
        new Thread( new Runnable()
        {
            @Override
            public void run()
            {
                String baseUrl =
                        String.format( "https://%s:%s/cxf", remotePeerInfo.getIp(), ChannelSettings.SECURE_PORT_X1 );
                WebClient client = RestUtil.createTrustedWebClient( baseUrl );// WebClient.create( baseUrl );
                try
                {
                    Response response = client.path( "peer/remove" ).type( MediaType.APPLICATION_JSON )
                                              .accept( MediaType.APPLICATION_JSON ).query( "rejectedPeerId",
                                    GSON.toJson( peerToUnregister.getId().toString() ) ).delete();
                    if ( response.getStatus() == Response.Status.NO_CONTENT.getStatusCode() )
                    {
                        LOG.info( response.toString() );
                        Notification.show( String.format( "Request sent to %s!", remotePeerInfo.getName() ) );
                        peersTable.removeItem( remotePeerInfo.getId() );
                        module.getPeerManager().unregister( remotePeerInfo.getId().toString() );
                    }
                    else
                    {
                        LOG.warn( "Response for registering peer: " + response.toString() );
                        Notification.show( "Failed to remove remote peer", Notification.Type.WARNING_MESSAGE );
                    }
                }
                catch ( PeerException e )
                {
                    LOG.error( "Error sending remove peer request", e );
                    Notification.show( "Error sending remove peer request", Notification.Type.WARNING_MESSAGE );
                }
            }
        } ).start();
    }


    private void approvePeerRegistration( final PeerInfo peerToUpdateOnRemote, final PeerInfo remotePeer )
    {
        new Thread( new Runnable()
        {
            @Override
            public void run()
            {
                //************ Send Trust SSL Cert **************************************

                KeyStore keyStore;
                KeyStoreData keyStoreData;
                KeyStoreManager keyStoreManager;

                keyStoreData = new KeyStoreData();
                keyStoreData.setupKeyStorePx2();

                keyStoreManager = new KeyStoreManager();
                keyStore = keyStoreManager.load( keyStoreData );

                String cert = keyStoreManager.exportCertificateHEXString( keyStore, keyStoreData );


                //***********************************************************************

                String baseUrl =
                        String.format( "https://%s:%s/cxf", remotePeer.getIp(), ChannelSettings.SECURE_PORT_X1 );
                WebClient client = RestUtil.createTrustedWebClient( baseUrl );//WebClient.create( baseUrl );
                client.type( MediaType.APPLICATION_FORM_URLENCODED ).accept( MediaType.APPLICATION_JSON );

                Form form = new Form();
                form.set( "approvedPeer", GSON.toJson( peerToUpdateOnRemote ) );
                form.set( "root_cert_px2", cert );

                try
                {
                    Response response = client.path( "peer/approve" ).put( form );
                    if ( response.getStatus() == Response.Status.OK.getStatusCode() )
                    {
                        LOG.info( response.readEntity( String.class ) );
                        remotePeer.setStatus( PeerStatus.APPROVED );
                        String root_cert_px2 = response.readEntity( String.class );
                        Notification.show( String.format( "Request sent to %s!", remotePeer.getName() ) );
                        //************ Save Trust SSL Cert **************************************

                        keyStoreData = new KeyStoreData();
                        keyStoreData.setupTrustStorePx2();
                        keyStoreData.setHEXCert( root_cert_px2 );
                        keyStoreData.setAlias( remotePeer.getId().toString() );

                        keyStoreManager = new KeyStoreManager();
                        keyStore = keyStoreManager.load( keyStoreData );

                        keyStoreManager.importCertificateHEXString( keyStore, keyStoreData );
                        //***********************************************************************

                        module.getSslContextFactory().reloadTrustStore();
                        //            new Thread( new RestartCoreServlet() ).start();

                        remotePeer.setStatus( PeerStatus.APPROVED );

                        Property property = peersTable.getItem( remotePeer.getId() ).getItemProperty( "Status" );
                        property.setValue( remotePeer.getStatus() );
                        module.getPeerManager().update( remotePeer );
                    }
                    else
                    {
                        LOG.warn( "Response for registering peer: " + response.toString() );
                        Notification.show( "Error approving peer request", Notification.Type.WARNING_MESSAGE );
                    }
                }
                catch ( Exception e )
                {
                    Notification.show( "Couldn't send approval request to peer", Notification.Type.ERROR_MESSAGE );
                }
            }
        } ).start();
    }


    /**
     * Peer request rejection intented to be handled before they exchange with keys
     *
     * @param peerToUpdateOnRemote - local peer info to update/send to remote peer
     * @param remotePeer - remote peer whose request was rejected
     */
    private void rejectPeerRegistration( final PeerInfo peerToUpdateOnRemote, final PeerInfo remotePeer )
    {
        new Thread( new Runnable()
        {
            @Override
            public void run()
            {
                String baseUrl =
                        String.format( "https://%s:%s/cxf", remotePeer.getIp(), ChannelSettings.SECURE_PORT_X1 );
                WebClient client = RestUtil.createTrustedWebClient( baseUrl );// WebClient.create( baseUrl );
                client.type( MediaType.APPLICATION_FORM_URLENCODED ).accept( MediaType.APPLICATION_JSON );

                Form form = new Form();
                form.set( "rejectedPeerId", peerToUpdateOnRemote.getId().toString() );

                try
                {
                    Response response = client.path( "peer/reject" ).put( form );
                    if ( response.getStatus() == Response.Status.NO_CONTENT.getStatusCode() )
                    {
                        LOG.info( "Successfully reject peer request" );
                        Notification.show( String.format( "Request sent to %s!", remotePeer.getName() ) );

                        //TODO maybe will implement certificates exchange later on initial request, before peer approves
                        // initializer' request
                        //************ Delete Trust SSL Cert **************************************
                        //            KeyStore keyStore;
                        //            KeyStoreData keyStoreData;
                        //            KeyStoreManager keyStoreManager;
                        //
                        //            keyStoreData = new KeyStoreData();
                        //            keyStoreData.setupTrustStorePx2();
                        //            keyStoreData.setAlias( remotePeer.getId().toString() );
                        //
                        //            keyStoreManager = new KeyStoreManager();
                        //            keyStore = keyStoreManager.load( keyStoreData );
                        //
                        //            keyStoreManager.deleteEntry( keyStore, keyStoreData );
                        //***********************************************************************
                        remotePeer.setStatus( PeerStatus.REJECTED );
                        Property property = peersTable.getItem( remotePeer.getId() ).getItemProperty( "Status" );
                        property.setValue( remotePeer.getStatus() );
                        module.getPeerManager().update( remotePeer );
                    }
                    else
                    {
                        LOG.warn( "Response for registering peer: " + response.toString() );
                    }
                }
                catch ( Exception e )
                {
                    LOG.error( "Rejecting peer registration failed", e );
                    Notification.show( "Peer reject request failed", Notification.Type.WARNING_MESSAGE );
                }
            }
        } ).start();
    }


    /**
     * Send peer registration request for further handshakes.
     *
     * @return - vaadin button with request initializing click listener
     */
    private Button createRegisterButton()
    {
        registerRequestButton = new Button();
        registerRequestButton.setCaption( "Register" );
        registerRequestButton.setImmediate( true );
        registerRequestButton.setWidth( "-1px" );
        registerRequestButton.setHeight( "-1px" );

        registerRequestButton.addClickListener( new Button.ClickListener()
        {
            @Override
            public void buttonClick( final Button.ClickEvent clickEvent )
            {
                getUI().access( new Runnable()
                {
                    @Override
                    public void run()
                    {
                        String ip = ipTextField.getValue();
                        LOG.warn( ip );

                        PeerInfo selfPeer = module.getPeerManager().getLocalPeerInfo();
                        registerMeToRemote( selfPeer, ip );
                        showPeersButton.click();
                    }
                } );
            }
        } );

        return registerRequestButton;
    }
}
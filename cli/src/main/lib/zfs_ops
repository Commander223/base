#!/bin/bash

# --------------------------------------------------------------------------
# Bunch-O ZFS convenience operations
# --------------------------------------------------------------------------


# rename datasets and set mount point for rootfs
function fs_rename_datasets_set_mount_point {
  local src="$1"
  local dst="$2"
  local dst_rootfs="$3"
  zfs rename "lxc-data/$src-home" "lxc-data/$dst-home"
  zfs rename "lxc-data/$src-var"  "lxc-data/$dst-var"
  zfs rename "lxc/$src-opt" "lxc/$dst-opt"
  zfs rename "lxc/$src" "lxc/$dst"
  zfs set mountpoint="$dst_rootfs" "lxc/$dst"

  zfs mount "lxc/$dst"
  zfs mount "lxc/$dst-opt"
  zfs mount "lxc-data/$dst-home"
  zfs mount "lxc-data/$dst-var"
}

function fs_clone {
  local parent_snap="$1"
  local child_ds="$2"
  zfs clone "$parent_snap" "$child_ds"
}
function fs_set_mountpoint {
  local child_roofs="$1"
  local child="$2"
  zfs set mountpoint=$child_rootfs lxc/$child
}

function fs_addmount {
  local name=$1
  local mount=$2
  local zpool=$3
  local dataset=$zpool/$name-$mount

  echo Creating $dataset dataset for $mount mount entry
  zfs create $dataset

  if [ -z "`zfs list $dataset`" ]; then
    echo Could not create $dataset dataset 
    exit 1
  else
    echo Created $dataset dataset, adding $mount mount entry
    echo lxc.mount.entry = /$dataset $mount none bind,rw 0 0 \
         >> /var/lib/lxc/$name/config
  fi
  echo Copying $mount data from rootfs to new $dataset dataset
  pushd .
  local mountpath=/var/lib/lxc/$name/rootfs/$mount
  cd $mountpath

  if [ -n "`ls -A $mountpath`" ]; then
    # We use tar to preserve permissions: do NOT use cp or mv
    tar -c * | tar -x -C /$dataset
    echo Deleting $mount contents from rootfs
    rm -rf /var/lib/lxc/$name/rootfs/$mount/*
  else
    echo Nothing within $mountpath, abandoning copy
  fi

  popd

  # Time to Snapshot and Apply Holds
  zfs snapshot $dataset'@template'
  zfs hold keep $dataset'@template'
  return
}

#snaphost ll holds on clone's rootfs
function fs_snap_hold_readonly {
  local lxc_template="$1"
  zfs snapshot lxc/$lxc_template@template
  zfs hold keep lxc/$lxc_template@template
  zfs set readonly=on lxc/$lxc_template

  zfs snapshot lxc/$lxc_template-opt@template
  zfs hold keep lxc/$lxc_template-opt@template
  zfs set readonly=on lxc/$lxc_template-opt

  zfs snapshot lxc-data/$lxc_template-var@template
  zfs hold keep lxc-data/$lxc_template-var@template
  zfs set readonly=on lxc-data/$lxc_template-var

  zfs snapshot lxc-data/$lxc_template-home@template
  zfs hold keep lxc-data/$lxc_template-home@template
  zfs set readonly=on lxc-data/$lxc_template-home
}

function fs_recv {
  local template="$1"
  local deltas="$2"
  local lxc_rootfs="$3"
  zfs recv lxc/$template < $deltas/rootfs.delta
  zfs set mountpoint=$lxc_rootfs lxc/$template
  zfs recv lxc/$template-opt < $deltas/opt.delta
  zfs recv lxc-data/$template-var < $deltas/var.delta
  zfs recv lxc-data/$template-home < $deltas/home.delta
}

#generate delta images of all filesystems
function fs_send {
  local parent="$1"
  local container="$2"
  local deltas="$3"
  zfs send -I "lxc/$parent@template" "lxc/$container@template" > "$deltas/rootfs.delta"
  zfs send -I "lxc/$parent-opt@template" "lxc/$container-opt@template" > "$deltas/opt.delta"
  zfs send -I "lxc-data/$parent-var@template" "lxc-data/$container-var@template" > "$deltas/var.delta"
  zfs send -I "lxc-data/$parent-home@template" "lxc-data/$container-home@template" > "$deltas/home.delta"
}

function fs_remove_mount {
  child="$1"
  parent="$2"
  partition="$3"
  pool="$4"

  child_ds="$pool/$child-$partition"
  parent_ds="$pool/$parent-$partition"

  for snap in `zfs list -t snapshot -o name -H | grep $child_ds@`; do
    for hold in `zfs holds -r $snap | grep $snap | awk '{print $2}'`; do
      zfs release $hold $snap
      msg_info "    - \"$hold\" hold removed from \"$snap\""
    done

    zfs destroy $snap
    msg_info "    - \"$snap\" snapshot destroyed"
  done

  # Need to destroy mount
  zfs destroy $child_ds
  msg_info "    - \"$child_ds\" dataset destroyed"
}


#release all holds on clone's rootfs snaps and delete snaps
function fs_rls_holds_delete_snaps {
  local clone="$1"
  for snap in `zfs list -t snapshot -o name -H | grep $clone@`; do
    for hold in `zfs holds -r $snap | grep $snap | awk '{print $2}'`; do
      zfs release $hold $snap
      msg_info "    - \"$hold\" hold removed from $snap"
    done

    zfs destroy $snap
    msg_info "    - \"$snap\" snapshot destroyed"
  done
}

#demote template
function fs_demote_template {
  local temp="$1"  
  local lxc_path="/var/lib/lxc/$temp"

  cat $lxc_path/config | \
    grep -v "lxc.hook.pre-start" | \
    grep -v "subutai.template.package" | \
    grep -v "subutai.git.uuid" >> $lxc_path/config.new
  rm $lxc_path/config
  mv $lxc_path/config.new $lxc_path/config

  local var_snap="lxc-data/$temp-var@template"
  zfs release keep "$var_snap"
  zfs destroy "$var_snap"
  zfs set readonly=off "lxc-data/$temp-var"

  local home_snap="lxc-data/$temp-home@template"
  zfs release keep "$home_snap"
  zfs destroy "$home_snap"
  zfs set readonly=off "lxc-data/$temp-home"

  local opt_snap="lxc/$temp-opt@template"
  zfs release keep "$opt_snap"
  zfs destroy "$opt_snap"
  zfs set readonly=off "lxc/$temp-opt"

  local root_snap="lxc/$temp@template"
  zfs release keep "$root_snap"
  zfs destroy "$root_snap"
  zfs set readonly=off "lxc/$temp"

}

# returns the children of the provided container(arg $1)
function fs_get_children_list {
  local parent="$1"
  local snap=

  # we got a dataset instead of a clone name
  if [ -n "`echo $parent | egrep 'lxc.*/'`" ]; then
    snap="$parent@template"
  else
    snap="lxc/$parent@template"
  fi
  local count=0
  for ds in `zfs get origin | grep $snap | awk '{print $1}' | grep -v $snap`
  do
    children_list[$count]=`fs_ctnr_from_ds $ds`
    count=`expr $count + 1`
  done

  echo ${children_list[*]}
}


# prints out the children for a ds or container name (arg $1)
# counts and prints out the children
# returns the child count
function fs_get_children {
  local parent="$1"
  local snap=

  # we got a dataset instead of a clone name
  if [ -n "`echo $parent | egrep 'lxc.*/'`" ]; then 
    snap="$parent@template"
  else
    snap="lxc/$parent@template"
  fi

  local count=0
  for ds in `zfs get origin | grep $snap | awk '{print $1}' | grep -v $snap`
  do
    msg_info "        -> \"`fs_ctnr_from_ds $ds`\" is a child of $parent"
    count=`expr $count + 1`
  done

  return $count
}


# assert snapshot (arg $1) does NOT exist, if it does show usage (arg $2)
# warning: exits!
function fs_assert_nosnap {
  local snap="$1"
  local usage="$2"

  if [ "$snap" == "`zfs list -t snapshot -o name -H $snap`" ]; then
    msg_error "Snapshot \"$snap\" already exists!"
    show_usage "$usage"
  fi
}


# assert snapshot (arg $1) exists, if it does NOT show usage (arg $2)
# warning: exits!
function fs_assert_snap {
  local snap="$1"
  local usage="$2"

  if [ -z "`zfs list -t snapshot -o name -H $snap`" ]; then
    msg_error "Snapshot \"$snap\" does NOT exist!"
    show_usage "$usage"
  fi
}


# assert dataset (arg $1) does NOT exist, if it does show usage (arg $2)
# warning: exits!
function fs_assert_nods {
  local ds="$1"
  local usage="$2"

  if [ -n "`zfs list -o name -H | grep $ds`" ]; then
    msg_error "ZFS dataset \"$ds\" already exists!"
    show_usage "$usage"
  fi
}


# assert dataset (arg $1) exists, if it does NOT show usage (arg $2)
# warning: exits!
function fs_assert_ds {
  local ds="$1"
  local usage="$2"

  if [ -z "`zfs list -o name -H $ds`" ]; then
    msg_error "ZFS dataset \"$ds\" does NOT exist!"
    show_usage "$usage"
  fi
}


# checks if the container (arg $1) is a template, echo "true"/"false"
function fs_is_template {
  local c="$1"
  if [ -z "`zfs list -t snapshot -o name -H | grep "lxc/$c@template"`" ]; then
    echo false
  else
    echo true
  fi
}


# gets the parent of a container
# first argument $1 is the name of the child container
# master returns master
function fs_get_parent {
  local c="$1"

  if [ "$c" == "master" ]; then
    echo master
    return
  fi

  local snap=`zfs get origin -o value -H lxc/$c`
  echo `fs_ctnr_from_ds $snap`
}


# extracts the container name from a dataset or a dataset snapshot
function fs_ctnr_from_ds {
  local ds="$1"
  echo $ds | sed -e 's/lxc.*\///' -e 's/@.*//' -e 's/-.*//'
}


# extracts the zpool name from a dataset or a dataset snapshot
function fs_pool_from_ds {
  local ds="$1"
  echo $ds | sed -e 's/\/.*//'
}


# extracts the snapshot name from a dataset snapshot
function fs_snap_from_ds {
  local ds="$1"
  echo $ds | sed -e 's/.*@//'
}


# extracts the partition name from a dataset or a dataset snapshot
function fs_part_from_ds {
  local ds="$1"
  echo $ds | sed -e 's/lxc.*\///' -e 's/@.*//' -e 's/.*-//'
}


# lists all the templates available
function fs_list_templates {
  for l in `zfs list -t snapshot -o name -H | grep @template | grep -v -`; do
    echo `fs_ctnr_from_ds $l`
  done
}

function fs_copy_ds {
  local from_ds="$1"

  if [ -n "`echo $from_ds | grep -`" ]; then
    local from_part="`fs_part_from_ds $from_ds`"
  else
    local from_part=""
  fi

  local from_pool="`fs_pool_from_ds $from_ds`"
  local from_lxc="`fs_ctnr_from_ds $from_ds`"
  local parent_lxc="`fs_get_parent $from_lxc`"
  local to_ds="$2"

  if [ -z "$from_part" ]; then 
    local parent_ds="$from_pool/$parent_lxc"
  else
    local parent_ds="$from_pool/$parent_lxc-$from_part"
  fi

  local parent_snap="$parent_ds@template"

  # make sure the from_ds exists and the to_ds does not
  fs_assert_ds "$from_ds"
  fs_assert_nods "$to_ds"
  fs_assert_ds "$parent_ds"
  fs_assert_snap "$parent_snap"

  local now=`date +"%m_%d_%Y"`
  local from_snap="$from_ds@$now"

  zfs snapshot "$from_snap"
  local stream="$SUBUTAI_TMPDIR/$parent_lxc$from_lxc$now"
  zfs send -I "$parent_snap" "$from_snap" > "$stream"
  zfs recv "$to_ds" < "$stream"

  # cleanup
  rm "$stream"
  zfs destroy "$from_snap"
  zfs destroy "$to_ds@$now"
}

function fs_get_quota {
  local container=$1

  local lxc_home=$(fs_quota_operations "lxc-data/$container-home")
  local lxc_var=$(fs_quota_operations "lxc-data/$container-var")
  local lxc_opt=$(fs_quota_operations "lxc/$container-opt")
  local lxc_rootfs=$(fs_quota_operations "lxc/$container")

  printf "Container home:\t%s\n" $lxc_home
  printf "Container opt:\t%s\n" $lxc_opt
  printf "Container var:\t%s\n" $lxc_var
  printf "Container rootfs:\t%s\n" $lxc_rootfs
}


function fs_get_quota_exact_values {
  local container=$1

  local lxc_home=$(fs_quota_operations_exact_value "lxc-data/$container-home")
  local lxc_var=$(fs_quota_operations_exact_value "lxc-data/$container-var")
  local lxc_opt=$(fs_quota_operations_exact_value "lxc/$container-opt")
  local lxc_rootfs=$(fs_quota_operations_exact_value "lxc/$container")

  printf "Container home:\t%s\n" $lxc_home
  printf "Container opt:\t%s\n" $lxc_opt
  printf "Container var:\t%s\n" $lxc_var
  printf "Container rootfs:\t%s\n" $lxc_rootfs
}


function fs_set_quota {
  local container=$1
  local directory=$2
  local quota_value=$3

  case $directory in
    "home" )
        container="lxc-data/$container-home";
      ;;
      "var")
        container="lxc-data/$container-var";
      ;;
      "opt")
        container="lxc/$container-opt";
      ;;
      "rootfs")
        container="lxc/$container";
      ;;
      \?)
        echo "Wrong directory name.";
        exit 1;
      ;;
  esac

  if [ -z "$quota_value" ]; then
    echo "Please provide with quota value  for function to work in proper way.";
    exit 1;
  fi
  fs_quota_operations $container $quota_value
}


function fs_get_disk_info {
  local container=$1
  local dataset=$2
  local disk_parameter=$3

  case $dataset in
    "home")
      dataset_name="lxc-data/$container-home";
      ;;
    "var")
      dataset_name="lxc-data/$container-var";
      ;;
    "opt")
      dataset_name="lxc/$container-opt";
      ;;
    "rootfs")
      dataset_name="lxc/$container";
      ;;
    \?)
      echo "Unsupported dataset $dataset! Aborting..";
      exit 1;
      ;;
  esac
  zfs get -p $disk_parameter $dataset_name | grep "$disk_parameter" | awk '{ print $3 }'
}


function fs_get_available_disk {
  local container=$1
  local dataset=$2
  fs_get_disk_info $container $dataset "available"
}


function fs_get_used_disk {
  local container=$1
  local dataset=$2
  fs_get_disk_info $container $dataset "used"
}


function fs_get_mount_point {
  local dataset=$1
  zfs get mountpoint $dataset | grep $dataset | awk '{ print $3 }'
}


# Returns total disk size of the resource host
# by pool name in bytes
function fs_get_physical_total_disk {
  local pool=$1
  zpool get -p size $pool | grep "$pool" | awk '{ print $3 }'
}


# Returns available disk size of the resource host
# by pool name in bytes
function fs_get_physical_available_disk {
  local pool=$1
  zfs get -p available $pool | grep "$pool" | awk '{ print $3 }'
}


# Returns used disk size of the resource host
# by pool name in bytes
function fs_get_physical_used_disk {
  local pool=$1
  zfs get -p used $pool | grep "$pool" | awk '{ print $3 }'
}

function fs_quota_operations {
  local container=$1
  local quota_value=$2
  local cmd=
  if [ -z $quota_value ]; then
    cmd=$(zfs get quota $container)
    echo $cmd | awk '{print $7}'
  else
    cmd=$(zfs set quota=$quota_value $container)
    echo $cmd
  fi
}


function fs_quota_operations_exact_value {
  local container=$1
  local cmd=
  if [ -z $quota_value ]; then
    zfs get -p quota $container | grep "$container" | awk '{print $3}'
  fi
}

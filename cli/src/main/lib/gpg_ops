#!/bin/bash

# --------------------------------------------------------------------------
# Bunch-O GnuGP key related operations
# --------------------------------------------------------------------------

# checks if the given key_id exists in private keyring
# parameters:
#   1) key id
assert_key_exists_private_key_ring(){
  key_id=$1
  if [ -z $key_id ];then
    echo "missing key id "
    exit 1
  fi
  all_secs=$(echo `gpg2 --list-secret-key | grep 'sec' | cut -d "/" -f2 | cut -d " " -f1 | tail -n +1`)
  all_ssbs=$(echo `gpg2 --list-secret-key | grep '^ssb' | cut -d "/" -f2 | cut -d " " -f1 | tail -n +1`)

  # search in pub keys
  IFS=' ' read -a array <<< "$all_secs"
  for element in "${array[@]}"
  do
    if [ "$element" == $key_id ];then
      return
    fi
  done

  # search in sub keys
  IFS=' ' read -a array <<< "$all_ssbs"
  for element in "${array[@]}"
  do
  if [ "$element" == $key_id ];then
    return
  fi
  done
  msg_error "key id $key_id does not exist in private keyring. (check with \"gpg2 --list-secret-keys\")"
  exit 1
}



# checks if the given key_id exists in keyring
# parameters:
#   1) key id
assert_key_exists(){
  key_id=$1
  if [ -z $key_id ];then
    echo "missing key id "
    exit 1
  fi
  all_pubs=`list_pubkeys`
  all_subs=`list_subkeys`

  
  # search in pub keys
  IFS=' ' read -a array <<< "$all_pubs"
  for element in "${array[@]}"
  do
    if [ "$element" == $key_id ];then
      return
    fi  
  done

  # search in sub keys
  IFS=' ' read -a array <<< "$all_subs"
  for element in "${array[@]}"
  do
  if [ "$element" == $key_id ];then
    return
  fi
  done
  msg_error "key id $key_id does not exist in public keyring (check with \"gpg2 --list-keys\")"
  exit 1
}


# This function is used to print output table in an alinged fashion.
# It caclucates the length of strings in column, and puts white spaces accordingly.
find_len(){
  if [ $# == 1 ];then
    target=$1
    max_size=0
    all_pubs=`list_pubkeys`
    IFS=' ' read -a array <<< "$all_pubs"
    for element in "${array[@]}"
    do
      case $target in
        sub | pub )
          sub_ids=$(echo `gpg2 --list-key  $element | grep $target' ' | cut -d "/" -f2 | cut -d " " -f1`)
          result=""
          IFS=' ' read -a array <<< "$sub_ids"
          for element in "${array[@]}"
          do
            result=$result$element:
          done
          result=$(echo $result | sed s'/.$//')
          ;;
        name )
          result=$(echo `gpg2 --list-key $element | grep 'uid'  | sed 's/([^)]*[^(]//g' | awk '{print $(NF-1)}'`)
          ;;
        mail )
          result=$(echo `gpg2 --list-key $element | grep 'uid'  | awk '{print $NF}' |  sed 's/^.\(.*\).$/\1/'`)
          ;;
      esac
      size=${#result}
      if (( $size > $max_size ));then
        max_size=$size;
      fi
   done
   echo $max_size
  elif [ $# == 2 ]; then
    key_id=$1
    assert_key_exists $key_id
    target=$2
    case $target in
      sub | pub )
        sub_ids=$(echo `gpg2 --list-key  $key_id | grep $target' ' | cut -d "/" -f2 | cut -d " " -f1`)
        IFS=' ' read -a array <<< "$sub_ids"
        for element in "${array[@]}"
        do
          result=$result$element:
        done
        result=$(echo $result | sed s'/.$//')
        ;;
      name )
        result=$(echo `gpg2 --list-key $element | grep 'uid'  | sed 's/([^)]*[^(]//g' | awk '{print $(NF-1)}'`)
        ;;
      mail )
        result=$(echo `gpg2 --list-key $element | grep 'uid'  | awk '{print $NF}' |  sed 's/^.\(.*\).$/\1/'`)
        ;;
    esac
    size=${#result}
    echo $size
  fi
}


# lists all public keys
list_pubkeys(){
  echo `gpg2 --list-key | grep '^pub' | cut -d "/" -f2 | cut -d " " -f1 | tail -n +1`
}


# lists all subkeys 
list_subkeys(){
  echo `gpg2 --list-key | grep '^sub' | cut -d "/" -f2 | cut -d " " -f1 | tail -n +1`
}


# Lists all key pairs in summarized format
list_all(){
  all_pubs=`list_pubkeys`
  IFS=' ' read -a array <<< "$all_pubs"
  print_keys array[@]
}


# summarized the key in this format:
# pubkey subkey(s) name email
# AC1FA4D2   12C8BEC8:698F684D     salih      salih@gmail.com
# 6528BEAC   74F78A01              ahmet      ahmet@gmail.com
# 
# Note: if there are multiple subkey, they separated by ":".
#
# parameters:
#   1) key id
summarize_key(){
  key_id=$1
  assert_key_exists $key_id
  if [ -z `is_subkey $key_id` ]; then
    key_id=`get_pubkey_of_subkey $key_id`    
  fi

  output=`gpg2 --list-keys | sed -n '/'$key_id'/,/^$/p'`
  pub_id=`echo -e "$output" | grep 'pub' | cut -d "/" -f2 | cut -d " " -f1`
  sub_ids=$(echo `echo -e "$output" | grep '^sub' | cut -d "/" -f2 | cut -d " " -f1`)
  email=`echo -e "$output" | grep uid  | awk '{print $NF}' |  sed 's/^.\(.*\).$/\1/'`
  name=`echo -e "$output" | grep uid  | sed 's/([^)]*[^(]//g' | awk '{print $(NF-1)}'`
  # trustLevel=`echo -e "$output" | grep uid  | sed 's/([^)]*[^(]//g' | cut -d "[" -f2 | cut -d "]" -f1`
  # expiry=`echo -e "$output" | grep '^pub'  | sed 's/([^)]*[^(]//g' | awk '{print $(3)}'`

  concatinate=""
  IFS=' ' read -a array <<< "$sub_ids"
  for element in "${array[@]}"
  do
    concatinate=$concatinate$element:
  done
  concatinate=$(echo $concatinate | sed s'/.$//')
  echo $pub_id $concatinate $name $email
}


# prints header part of list commands
print_keys(){
  declare -a list=("${!1}")
  for (( i=0; i<${#list[@]}; i++ ));
  do
    ## print header
    if [ $i == 0 ]; then 
      if [ ${#list[@]} == 1 ];then
        space_list=`find_white_space_amount ${list[$i]}`
      else
        space_list=`find_white_space_amount`
      fi
      IFS=' ' read -a spaces <<< $space_list
      subutai_quiet=false
      if [ "false" == "$subutai_quiet" ];then
        printf "%-${spaces[0]}s %-${spaces[1]}s %-${spaces[2]}s %-${spaces[3]}s" "pubkey" "subkey" "name" "email"
        printf "\n"
        printf "%-${spaces[0]}s %-${spaces[1]}s %-${spaces[2]}s %-${spaces[3]}s" "------" "------" "----" "-----"
        printf "\n"
      fi
    fi
    # print keys in summarized format
    summary=`summarize_key ${list[$i]}`
    # echo "index " $i " : "  ${list[$i]}
    # echo "summary: " $summary
    printf "%${spaces[0]}s %-${spaces[1]}s %-${spaces[2]}s %-${spaces[3]}s" $summary
    printf "\n"
  done
}


# finds the amount of white space to be inserted 
# between columns while printing output of list commands.
find_white_space_amount(){
  white_space_size_pub=`find_len $1 'pub'`
  white_space_size_sub=`find_len $1 'sub'`
  white_space_size_name=`find_len $1 'name'`
  white_space_size_email=`find_len $1 'mail'`
  echo $white_space_size_pub $white_space_size_sub $white_space_size_name $white_space_size_email
}


# extract fingerprint of given key id
get_fingerprint(){
  key_id=$1
  assert_key_exists $key_id
  echo `gpg2 --list-secret-keys --with-colons --fingerprint $key_id | sed -n 's/^fpr:::::::::\([[:alnum:]]\+\):/\1/p'`
}


# extracts keygrip of given key id
get_keygrip(){
  key_id=$1
  assert_key_exists $key_id
  echo `gpg2 --with-keygrip -k | awk '/'$key_id'/{getline; print}' | awk '{print $3}'`  
}


# checks if gpg agent is running with correct switches
assert_gpg_agent_is_running(){
  is_running=`ps axu | grep [g]pg-agent | grep enable-ssh-support`
  if [[ -z $is_running ]];then
    msg_error "gpg-agent is not running! (start it with \"--enable-ssh-support\" switch)"
    exit 1
  fi
}


# checks if given key id belong to a pubkey or not
is_pubkey(){
  key_id="$1"
  assert_key_exists $key_id
  all_pubs=`list_pubkeys` 
  # search in pub keys
  IFS=' ' read -a array <<< "$all_pubs"
  for element in "${array[@]}"
  do
    if [ "$element" == $key_id ];then
      return
    fi  
  done
  echo "false"
}


# checks if given key id belong to a subkey or not
is_subkey(){
  key_id="$1"
  assert_key_exists $key_id
  all_subs=`list_subkeys` 
  # search in pub keys
  IFS=' ' read -a array <<< "$all_subs"
  for element in "${array[@]}"
  do
    if [ "$element" == $key_id ];then
      return
    fi  
  done
  echo "false"
}


# return corresponding pubkey id of given subkey
# parameters:
#   1) subkey_id (key_id)
get_pubkey_of_subkey(){
  subkey_id="$1"
  assert_key_exists $subkey_id
  all_pubs=`list_pubkeys` 
  IFS=' ' read -a array <<< "$all_pubs"
  for element in "${array[@]}"
  do
    output=`gpg2 --list-keys | sed -n '/'$element'/,/^$/p'`
    sub_ids=$(echo `echo -e "$output" | grep '^sub' | cut -d "/" -f2 | cut -d " " -f1`)
    IFS=' ' read -a array <<< "$sub_ids"
    for index in "${array[@]}"
    do
      if [ "$index" == $subkey_id ]; then
        echo $element
        return
      fi
    done
  done
}


# exports public part of given key id which is
# compatible with authorized_key file.
#
# Note: We may need to just allow subkey ids as arguments
#
export_key_compatible_with_authorized_key_file(){
  assert_gpg_agent_is_running
  key_id=$1
  assert_key_exists $key_id
  keygrip=`get_keygrip $key_id`
  sshcontrol=${HOME}/.gnupg/sshcontrol
  if [[ -z  `cat $sshcontrol | grep $keygrip` ]]; then
    echo $keygrip >> $sshcontrol
  else
    sed -i '/'$keygrip'/d' $sshcontrol
    echo $keygrip >> $sshcontrol
  fi
  public_part=`ssh-add -L | sed '$!d'`
  echo $public_part | sed 's/([^)]*[^(]//g'
}


# check if given email is valid
assert_email_validity(){
  email=$1
  if [ -z $email ];then
     msg_error "Empty email string !"
     exit 1
  fi 
  echo "$email" | grep '^[a-zA-Z0-9]*@[a-zA-Z0-9]*\.[a-zA-Z0-9]*$' > /dev/null 2>&1
  if [ ! $? -eq 0 ]; then
    msg_error "Invalid email address !"
    exit 1
  fi
}


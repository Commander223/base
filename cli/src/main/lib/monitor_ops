#!/bin/bash

# ==========================================================================
# Set of functions for monitoring functionality
# ==========================================================================

metric_list=("ram" "cpu")

function get_total_ram {
  local lxc="$1"
  lxc_assert $lxc > /dev/null

  local physical_total_ram=$(get_physical_total_ram)
  #TODO check if there is a limit set for lxc
  echo "$physical_total_ram"
}


function get_available_ram {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  # TODO return available ram for container if there is a limit set
  get_physical_available_ram
}


function get_used_ram {
  local lxc=$1
  lxc_assert $lxc > /dev/null

  local used_ram=$(cat /sys/fs/cgroup/memory/lxc/$lxc/memory.usage_in_bytes)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_ram
  fi
}


function get_used_cpu {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  
  local used_cpu=$(cat /sys/fs/cgroup/cpuacct/lxc/$lxc/cpuacct.usage)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_cpu
  fi
}


function get_physical_total_ram {
  local total_ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  echo "$(($total_ram_kb * 1024))"
}


function get_physical_available_ram {
  local total_ram=$(get_physical_total_ram)
  local used_ram=$(get_physical_used_ram)
  echo "$(($total_ram - $used_ram))"
}


function get_physical_used_ram {
  local used_ram=$(cat /sys/fs/cgroup/memory/memory.usage_in_bytes)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_ram
  fi
}


function get_physical_used_cpu {
  local used_cpu=$(cat /sys/fs/cgroup/cpuacct/cpuacct.usage)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_cpu
  fi
}


function get_available_disk {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo "100000"
}


function get_used_disk {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo "50000"
}


function get_total_disk {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo "150000"
}


function get_physical_available_disk {
  echo "400000"
}


function get_physical_used_disk {
  echo "150000"
}


function get_physical_total_disk {
  echo "550000"
}

function contains() {
    local n=$#
    local value=${!n}
    for ((i=1;i < $#;i++)) {
        if [ "${!i}" == "${value}" ]; then
            echo "y"
            return 0
        fi
    }
    echo "n"
    return 1
}

function create_rrd {
  local hostname=$1
  local metric_type=$2
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi
  
  mkdir -p $SUBUTAI_RRD_DIRECTORY > /dev/null 2>&1
  assert_metric "$metric_type"
  local database_file=$(get_database_file $hostname $metric_type)
  local dataset_name=$(get_dataset_name $metric_type)
  local update_sequence=$(get_update_sequence)
  pushd $SUBUTAI_RRD_DIRECTORY > /dev/null
  if [ -f $database_file ]; then
    msg_notice "    - $database_file already exists, skipping..."
    start_update_rrd "$hostname" "$metric_type" > /dev/null
    return
  fi
  rrdtool create "$database_file" --no-overwrite --step $update_sequence DS:"$dataset_name":GAUGE:$(($update_sequence * 2 - 1)):0:U RRA:LAST:0.5:1:1500
  msg_info "    - $metric_type rrd is created for $hostname"
  popd > /dev/null
  start_update_rrd "$hostname" "$metric_type" > /dev/null
}


function create_all_rrd {
  local hostname=$1
  for metric_type in "${metric_list[@]}"
  do
    create_rrd "$hostname" "$metric_type"
  done
}


function update_rrd {
  local hostname=$1
  local metric_type=$2

  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi
  assert_metric "$metric_type" 

  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  local tag=$(get_metric_tag $metric_type)
  local dataset_name=$(get_dataset_name $metric_type)
  local update_sequence=$(get_update_sequence)
  local metric_value=$(subutai monitor $hostname | awk -F"$tag" '{print $2}' | awk -F"," '{print $1}' | awk -F"\"" '{print $3}')

  msg_info "    - $metric_value is stored at `date +%s`"
  rrdtool update  "$database_file" --template "$dataset_name" N:"$metric_value"
}


function start_update_rrd {
  local hostname=$1
  local metric_type=$2
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  if [ ! -f $database_file ]; then
    msg_error "Please create the $metric_type rrd for $hostname first. Aborting!"
    exit 1
  fi

  assert_metric "$metric_type"
  # Remove cron job of host for metric_type if exists
  stop_update_rrd "$hostname" "$metric_type" > /dev/null
  #write out current crontab
  crontab -l > mycron
  #echo new cron into cron file
  echo "*/$(get_cron_interval_in_minutes) * * * * subutai monitor -u $metric_type $hostname" >> mycron
  #install new cron file
  crontab mycron
  rm mycron
}


function start_update_all_rrd {
  local hostname=$1

  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  for metric_type in "${metric_list[@]}"
  do
    start_update_rrd $hostname $metric_type > /dev/null
  done
}


function stop_update_rrd {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type"

  crontab -l | sed "/subutai monitor -u $metric_type $hostname/d" | crontab -
}


function stop_update_all_rrd {
  local hostname=$1

  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  for metric_type in "${metric_list[@]}"
  do
    stop_update_rrd $hostname $metric_type > /dev/null
  done
}



function query_rrd {
  local hostname=$1
  local metric_type=$2
  
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi
  assert_metric "$metric_type"

  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"

  local TIME=$(date +%s)
  local update_sequence=$(get_update_sequence)
  # Show last X entries
  local start_time=$(($update_sequence * 50))
  rrdtool fetch "$database_file" LAST -e $TIME -s e-"$start_time"sec
}


function destroy_monitor {
  local hostname=$1

  for metric_type in "${metric_list[@]}"
  do
    assert_metric "$metric_type"
    stop_update_rrd $hostname $metric_type
    local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
    rm -f $database_file > /dev/null 2>&1
    msg_info "    - $metric_type rrd of $hostname is destroyed"
  done
}


function assert_metric {
  if [ -z $metric_type ]; then
    msg_error "Metric type is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${metric_list[@]}" "$metric_type") != "y" ]; then
    msg_error "    - $metric_type is not supported metric type. Please provide one of the followings:"
    echo "      ${metric_list[@]}"
    exit 1
  fi
}

function get_dataset_name {
  local metric_type=$1

  assert_metric "$metric_type"
  #TODO define datasets for each passed metric_type
  echo "$metric_type"_used
}


function get_metric_tag {
  local metric_type=$1

  assert_metric "$metric_type"
  # uppercase first character of the passed metric_type like ram to Ram
  local metric_type="$(tr '[:lower:]' '[:upper:]' <<< ${metric_type:0:1})${metric_type:1}"

  echo "used$metric_type"
}


function get_database_file {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type" > /dev/null

  echo ""$metric_type"_"$hostname".rrd"
}

function get_cron_interval_in_minutes {
  echo "1"
}
function get_update_sequence {
  local interval_in_minutes=$(get_cron_interval_in_minutes)
  echo "$(($interval_in_minutes * 60))"
}

#!/bin/bash

# ==========================================================================
# Set of functions for monitoring functionality
# ==========================================================================

metric_list=("ram" "cpu" "diskVar" "diskOpt" "diskHome" "diskRootfs")
dataset_list=("var" "opt" "home" "rootfs")
pool_list=("lxc" "lxc-data")
parameter_list=("metricCollectionIntervalInMin" "maxSampleCount" "metricCountToAverageToAlert" "intervalBetweenAlertsInMin" "ramAlertThreshold" "cpuAlertThreshold" "diskAlertThreshold")


# returns the total ram capacity of the container
function get_total_ram {
  local lxc="$1"
  lxc_assert $lxc > /dev/null

  local physical_total_ram=$(get_physical_total_ram)
  local ram_quota=$(lxc_get_memory $lxc)
  assert_number "$ram_quota" > /dev/null

  if (( $(bc <<< "$ram_quota <= $physical_total_ram") == 1 )); then
    echo "$ram_quota"
    return
  fi
  echo "$physical_total_ram"
  return
}


# Returns maximum cpu time can be used within
# one second in terms of nanoseconds
function get_maximum_cpu_capacity_nanoseconds {
  local lxc="$1"
  lxc_assert $lxc > /dev/null

  local cfs_quota=$(lxc_get_cfs_quota $lxc)
  local cfs_period=$(lxc_get_cfs_period $lxc)
  local seconds_to_nanoseconds="1000000000"

  # Check if there is no quota set for lxc
  if [ "$cfs_quota" == -1 ]; then
    local cpu_core_quota=$(lxc_get_cpu_core_count $lxc)
    local result=$(echo $cpu_core_quota*$seconds_to_nanoseconds | bc)
    echo "$result"
    return
  fi

  local result=$(echo $cfs_quota*$seconds_to_nanoseconds/$cfs_period | bc)
  echo "$result"
  return
}


# returns how much long the physical machine
# can process the tasks within one second in nanoseconds
function get_physical_cpu_capacity_nanoseconds {
  local cpu_core=$(nproc)
  local seconds_to_nanoseconds="1000000000"
  local result=$(echo $cpu_core*$seconds_to_nanoseconds | bc)
  echo "$result"
  return
}


# returns the available ram of the container
function get_available_ram {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  local ram_quota=$(lxc_get_memory $lxc)
  local total_available_ram=$(get_physical_available_ram)
  local physical_total_ram=$(get_physical_total_ram)

  # return available ram for container if there is a limit set
  if (( $(bc <<< "$ram_quota < $physical_total_ram") == 1 )); then
    local used_ram=$(get_used_ram $lxc)
    local available_ram=$(($ram_quota - $used_ram))
    # TODO does this manipulation necessary?
    # check if available ram is greater than physical resource host's available ram
#    if [[ "$available_ram" -gt "$total_available_ram" ]]; then
#      echo $total_available_ram
#      return
#    fi
    echo $available_ram
    return
  fi
  # else return total available ram
  echo $total_available_ram
  return
}


# returns the amount of ram used by the container
# in bytes
function get_used_ram {
  local lxc=$1
  lxc_assert $lxc > /dev/null

  local used_ram=$(cat /sys/fs/cgroup/memory/lxc/$lxc/memory.usage_in_bytes)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_ram
    return
  fi
  echo 0
  return
}


# returns the average ram usage according to the passed sample count
# for the host. If sample count is bigger than the stored sample counts
# then it calculates the average according to the maximum available samples
function get_average_used_ram {
  local lxc=$1
  local sampleCountToAverage=$2
  local metric_type="ram"
  get_metric_average $lxc $sampleCountToAverage $metric_type
}


# returns the average disk usage according to the passed sample count
# for the host. If sample count is bigger than the stored sample counts
# then it calculates the average according to the maximum available samples
function get_average_used_disk_by_metric_type {
  local lxc=$1
  local metric_type=$2
  local sampleCountToAverage=$3
  get_metric_average $lxc $sampleCountToAverage $metric_type
}


# returns the average cpu usage according to the passed sample count
# for the host in terms of nanoseconds. If sample count is bigger than the stored sample counts
# then it calculates the average according to the maximum available samples
function get_average_cpu_usage_between_samples {
  local lxc=$1
  local sampleCountToAverage=$2
  local metric_type="cpu"
  local update_sequence=$(get_update_sequence $lxc $metric_type)
  local lxc_uptime_in_seconds=$(lxc_get_uptime_in_seconds $lxc)

  lxc_assert $lxc > /dev/null
  local numberExpression='^[0-9]+$'

  if [ -z "$sampleCountToAverage" ]; then
    msg_error "No value provided for sampleCountToAverage! Aborting.."
    exit 1
  fi

  # Check if the value is a number
  if ! [[ $sampleCountToAverage =~ $numberExpression ]] ; then
    msg_error "$sampleCountToAverage is not a number! Aborting.."
    exit 1
  fi

  assert_metric $metric_type > /dev/null

  local lxc_max_cpu_sample_count=$(echo $lxc_uptime_in_seconds/$update_sequence + 1 | bc)
#  msg_debug "lxc_max_cpu_sample_count: $lxc_max_cpu_sample_count"
  # Check if lxc is restarted within the interval of the samples
  if (( $(bc <<< "$lxc_max_cpu_sample_count < $sampleCountToAverage") == 1 )); then
    sampleCountToAverage=$lxc_max_cpu_sample_count
  fi
#  msg_debug "sampleCountToAverage: $sampleCountToAverage"
  local interval_time_in_seconds=$(echo $(($sampleCountToAverage+1))*$update_sequence | bc)
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $lxc $metric_type)"
  local cpu_values=$(rrdtool fetch "$database_file" LAST -e $(date +%s) -s e-"$interval_time_in_seconds"sec | grep "e+")

  local line_count=$(echo -e "$cpu_values" | wc -l)
#  msg_debug "line_count: $line_count"

  # without at least one sample, average cannot be calculated
  if [ $line_count -lt 2 ]; then
    local first_value=$(echo -e "$cpu_values" | sed -n 1p | cut -d':' -f2 | tr -d ' ' | sed -e 's/[eE]+*/*10^/')
    if [ "`is_number $first_value`" == "true" ]; then
      echo "$first_value"
      return
    fi
    echo "0"
    return
  fi

  local first_value=$(echo -e "$cpu_values" | sed -n 1p | cut -d':' -f2 | tr -d ' ' | sed -e 's/[eE]+*/*10^/')
  local first_timestamp=$(echo -e "$cpu_values" | sed -n 1p | cut -d':' -f1 | tr -d ' ')
  local last_value=$(echo -e "$cpu_values" | sed -e '$!d' | cut -d':' -f2 | tr -d ' ' | sed -e 's/[eE]+*/*10^/')
  local last_timestamp=$(echo -e "$cpu_values" | sed -e '$!d' | cut -d':' -f1 | tr -d ' ')

  local cpu_usage=$(echo $last_value - $first_value | bc)
  local time_elapsed=$(echo $last_timestamp - $first_timestamp | bc)
  # Remove insignificant bits
  cpu_usage=$(echo $cpu_usage | cut -d'.' -f1)

  if [ -z "$cpu_usage" ]; then
    echo "0"
    return
  fi

  # In case the first sample is greater than the last sample for cpu usage,
  # it means the container is restarted and calculate the average
  # via the next sample which would be the first sample of the restarted container
  if (( $(bc <<< "$last_value <= $first_value") == 1 )); then
    get_average_cpu_usage_between_samples $lxc $(echo $sampleCountToAverage -1 | bc)
    return
  fi

#  msg_debug "first_value: $first_value"
#  msg_debug "first_timestamp: $first_timestamp"
#  msg_debug "last_value:  $last_value"
#  msg_debug "last_timestamp: $last_timestamp"
#  msg_debug "line_count:  $line_count"
#  msg_debug "sampleCount: $sampleCountToAverage"
#  msg_debug "time_elapsed: $time_elapsed"
  echo $(($cpu_usage / $time_elapsed))
  return
}


# returns the average usage of the specified metric type according to the passed sample count
# for the host. If sample count is bigger than the stored sample counts
# then it calculates the average according to the maximum available samples
function get_metric_average {
  local lxc=$1
  local sampleCountToAverage=$2
  local metric_type=$3

  lxc_assert $lxc > /dev/null
  local numberExpression='^[0-9]+$'

  if [ -z "$sampleCountToAverage" ]; then
    msg_error "No value provided for sampleCountToAverage! Aborting.."
    exit 1
  fi

  # Check if the value is a number
  if ! [[ $sampleCountToAverage =~ $numberExpression ]] ; then
    msg_error "$sampleCountToAverage is not a number! Aborting.."
    exit 1
  fi

  if [ $sampleCountToAverage -lt 1 ]; then
    msg_error "Sample count to be averaged cannot be less than \"1\". Aborting!"
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  local maxSampleCount=$(get_max_sample_count)
  if [ $sampleCountToAverage -gt $maxSampleCount ]; then
    msg_error "Sample count cannot be greater than maximum sample count! Aborting.."
    exit 1
  fi

  local last_N_values=$(query_rrd $lxc "$metric_type" | tail -$sampleCountToAverage | grep "e+")
  if [ -z "$last_N_values" ]; then
    msg_error "No data found for $metric_type metric_type for $lxc! Aborting.."
    exit 1
  fi

  local sum=$(echo "0" | bc)
  local line_count=$(echo "$last_N_values" | wc -l)
  while read -r line; do
    value=$(echo $line | cut -d':' -f2 | tr -d ' ' | sed -e 's/[eE][+][0]/*10^/')
    sum=$(echo $sum+$value | bc)
  done <<< "$last_N_values"
  # Remove insignificant bits
  sum=$(echo $sum | cut -d'.' -f1)
  if [ -z "$sum" ]; then
    echo "0"
    return
  fi
  echo $(($sum / $line_count))
  return
}


# reports the total CPU time (in nanoseconds) consumed by all tasks in this cgroup
function get_used_cpu {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  
  local used_cpu=$(cat /sys/fs/cgroup/cpuacct/lxc/$lxc/cpuacct.usage)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_cpu
  fi
}


# returns the total ram capacity of the physical machine
# in bytes
function get_physical_total_ram {
  local total_ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  echo "$(($total_ram_kb * 1024))"
  return
}


# returns the available ram capacity of the physical machine
# in bytes
function get_physical_available_ram {
  local total_ram=$(get_physical_total_ram)
  local used_ram=$(get_physical_used_ram)
  echo "$(($total_ram - $used_ram))"
  return
}


# returns the used ram amount of the physical machine
# in bytes
function get_physical_used_ram {
  local used_ram=$(cat /sys/fs/cgroup/memory/memory.usage_in_bytes)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_ram
  fi
}


# reports the total CPU time (in nanoseconds) consumed by all tasks in this cgroup
function get_physical_used_cpu {
  local used_cpu=$(cat /sys/fs/cgroup/cpuacct/cpuacct.usage)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_cpu
  fi
}


# returns the available disk space of the specified dataset of container
# in terms of bytes
function get_available_disk_by_dataset {
  local lxc=$1
  local dataset=$2
  lxc_assert $lxc > /dev/null
  assert_dataset $dataset
  echo $(fs_get_available_disk "$lxc" "$dataset")
}


# returns the available disk space of "var" dataset of container
# in terms of bytes
function get_available_diskVar {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "var")
}


# returns the available disk space of "opt" dataset of container
# in terms of bytes
function get_available_diskOpt {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "opt")
}


# returns the available disk space of "home" dataset of container
# in terms of bytes
function get_available_diskHome {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "home")
}


# returns the available disk space of "rootfs" dataset of container
# in terms of bytes
function get_available_diskRootfs {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "rootfs")
}


# returns the used disk space of the specified dataset of container
# in terms of bytes
function get_used_disk_by_dataset {
  local lxc=$1
  local dataset=$2
  lxc_assert $lxc > /dev/null
  assert_dataset $dataset
  echo $(fs_get_used_disk "$lxc" "$dataset")
}


# returns the used disk space of "var" dataset of container
# in terms of bytes
function get_used_diskVar {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "var")
}


# returns the used disk space of "opt" dataset of container
# in terms of bytes
function get_used_diskOpt {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "opt")
}


# returns the used disk space of "home" dataset of container
# in terms of bytes
function get_used_diskHome {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "home")
}


# returns the used disk space of "rootfs" dataset of container
# in terms of bytes
function get_used_diskRootfs {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "rootfs")
}


# returns the total disk space of the specified dataset of container
# in terms of bytes
function get_total_disk_by_dataset {
  local lxc=$1
  local dataset=$2
  assert_dataset $dataset

#  local disk_quota=$(fs_get_quota_exact_values $lxc | grep "$dataset" | cut -d':' -f2 | tr -d '\040\011\015')
  local disk_quota=$(fs_get_quota_exact_values "$lxc" "$dataset")
  local metric_type=$(get_disk_metric_type_by_dataset $dataset)
  local physical_total_disk_dataset=$(get_physical_total_"$metric_type")
  local numberExpression='^[0-9]+$'

  # Return physical total disk if the disk quota is empty
  if [ -z "$disk_quota" ]; then
    echo "$physical_total_disk_dataset"
    return
  fi
  # Return physical total disk if the disk quota is not a number
  if ! [[ $disk_quota =~ $numberExpression ]] ; then
    echo "$physical_total_disk_dataset"
    return
  fi

  assert_number "$disk_quota"  > /dev/null

  # Return quota value set for disk if it is less than or equal to
  # physical total disk and if quota is not 0 meaning no limit defined
  if (( $(bc <<< "$disk_quota <= $physical_total_disk_dataset") == 1 )) && (("$disk_quota" > "0")); then
    echo "$disk_quota"
    return
  fi
  # Return physical total disk size if the quota set is greater than
  # the physical total disk
  echo "$physical_total_disk_dataset"
  return
}


# returns the total disk space of "var" dataset of container
# in terms of bytes
function get_total_diskVar {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "var")
}


# returns the used disk space of "opt" dataset of container
# in terms of bytes
function get_total_diskOpt {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "opt")
}


# returns the used disk space of "home" dataset of container
# in terms of bytes
function get_total_diskHome {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "home")
}


# returns the used disk space of "rootfs" dataset of container
# in terms of bytes
function get_total_diskRootfs {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "rootfs")
}


# returns the pool name of the specified dataset
function get_pool_by_dataset {
  local dataset=$1
  assert_dataset $dataset

  get_"$dataset"_dataset_pool
}

# returns the pool name where "var" dataset is mounted to
function get_var_dataset_pool {
  echo "lxc-data"
}


# returns the pool name where "opt" dataset is mounted to
function get_opt_dataset_pool {
  echo "lxc"
}


# returns the pool name where "home" dataset is mounted to
function get_home_dataset_pool {
  echo "lxc-data"
}


# returns the pool name where "rootfs" dataset is mounted to
function get_rootfs_dataset_pool {
  echo "lxc"
}


# returns the available disk space of the specified pool
function get_physical_available_disk_by_pool_name {
  local pool_name=$1
  assert_pool $pool_name
  echo $(fs_get_physical_available_disk "$pool_name")
}


# returns the available disk space of the pool where "var" dataset is mounted to
function get_physical_available_diskVar {
  local pool=$(get_var_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


# returns the available disk space of the pool where "opt" dataset is mounted to
function get_physical_available_diskOpt {
  local pool=$(get_opt_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


# returns the available disk space of the pool where "home" dataset is mounted to
function get_physical_available_diskHome {
  local pool=$(get_home_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


# returns the available disk space of the pool where "rootfs" is mounted to
function get_physical_available_diskRootfs {
  local pool=$(get_rootfs_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


# returns the used disk space of the pool specified pool
function get_physical_used_disk_by_pool_name {
  local pool_name=$1
  assert_pool $pool_name
  echo $(fs_get_physical_used_disk "$pool_name")
}


# returns the used disk space of the pool where "var" dataset is mounted to
function get_physical_used_diskVar {
  local pool=$(get_var_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


# returns the used disk space of the pool where "opt" dataset is mounted to
function get_physical_used_diskOpt {
  local pool=$(get_opt_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


# returns the used disk space of the pool where "home" dataset is mounted to
function get_physical_used_diskHome {
  local pool=$(get_home_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


# returns the used disk space of the pool where "rootfs" dataset is mounted to
function get_physical_used_diskRootfs {
  local pool=$(get_rootfs_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


# returns the total disk space of the specified pool
function get_physical_total_disk_by_pool_name {
  local pool_name=$1
  assert_pool $pool
  echo $(fs_get_physical_total_disk $pool_name)
  return
}


# returns the total disk space of the pool where "var" dataset is mounted to
function get_physical_total_diskVar {
  local pool=$(get_var_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


# returns the total disk space of the pool where "opt" dataset is mounted to
function get_physical_total_diskOpt {
  local pool=$(get_opt_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


# returns the total disk space of the pool where "home" dataset is mounted to
function get_physical_total_diskHome {
  local pool=$(get_home_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


# returns the total disk space of the pool where "rootfs" dataset is mounted to
function get_physical_total_diskRootfs {
  local pool=$(get_rootfs_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


# returns "y" if the array contains the passed value
# returns "n" if the array does not contain the passed value
function contains() {
    local n=$#
    local value=${!n}
    for ((i=1;i < $#;i++)) {
        if [ "${!i}" == "${value}" ]; then
            echo "y"
            return 0
        fi
    }
    echo "n"
    return 1
}


# creates the rrd file for the host along with the passed parameters if any
# and starts its monitoring which stores data on rrd database periodically
function create_rrd {
  local hostname=$1
  local metric_type=$2
  local parameters=$3
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  mkdir -p $SUBUTAI_RRD_DIRECTORY > /dev/null 2>&1
  assert_metric "$metric_type"

  local database_file=$(get_database_file $hostname $metric_type)
  local dataset_name=$(get_dataset_name $metric_type)

  if [ -f $SUBUTAI_RRD_DIRECTORY/$database_file ]; then
    msg_notice "    - $database_file already exists, skipping..."
    start_update_rrd "$hostname" "$metric_type" > /dev/null
    return
  fi

  # Assert no config file exists if parameter is passed
  if [ -n "$parameters" ]; then
    local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
    if [ -f $monitor_conf ]; then
      msg_notice "    - configuration file of $metric_type already exists for $hostname! Using existing configuration.."
    else
      # Save parameters inside configuration file
      store_monitor_configuration "$hostname" "$metric_type" "$parameters"
    fi
  fi

  # Setup configurations of monitoring infrastructure for host
  get_monitor_configuration "$hostname" "$metric_type"

  # Initialize following variables that depend on configuration file
  # after get_monitor_configuration call
  local update_sequence=$(get_update_sequence $hostname $metric_type)
  local maxSampleCount=$(get_max_sample_count)

  pushd $SUBUTAI_RRD_DIRECTORY > /dev/null

  rrdtool create "$database_file" --no-overwrite --step $update_sequence DS:"$dataset_name":GAUGE:$(($update_sequence * 2 - 1)):0:U RRA:LAST:0.5:1:$maxSampleCount
  msg_info "    - $metric_type rrd is created for $hostname"
  popd > /dev/null
  start_update_rrd "$hostname" "$metric_type" > /dev/null
}


# creates all rrd files of the supported metrics
function create_all_rrd {
  local hostname=$1
  local parameters=$2

  for metric_type in "${metric_list[@]}"
  do
    create_rrd "$hostname" "$metric_type" "$parameters"
  done
}


# stores the value of the metric in its rrd database with the current timestamp
# if the metric for host is enabled for update
function update_rrd {
  local hostname=$1
  local metric_type=$2

  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  assert_metric "$metric_type"
  get_monitor_configuration "$hostname" "$metric_type"


  get_monitor_update_configuration "$hostname"
  local monitor_update_conf=$(get_monitor_update_configuration_file "$hostname")
  local update_entry_in_configuration=$(get_update_entry_in_configuration "$hostname" "$metric_type")
  local value=$(get_update_entry_value_in_configuration $update_entry_in_configuration)
  # exit if the metric of host is not set
  if [ "$value" != "true" ]; then
    msg_notice "    - $metric_type metric for $hostname is not enabled for monitoring, skipping..."
    return
  fi

  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  local tag=$(get_metric_tag $metric_type)
  local dataset_name=$(get_dataset_name $metric_type)
  local update_sequence=$(get_update_sequence $hostname $metric_type)
  local function_name=$(get_resource_usage_function_name_by_metric_type $hostname $metric_type)
  local metric_value=$($function_name $hostname)
  local current_time=`date +%s`
  message="$metric_value is stored at $current_time for $metric_type($hostname) metric"
  msg_info "    - $message"
  rrdtool update  "$database_file" --template "$dataset_name" N:"$metric_value"
}


# calls update_rrd function for all the supported metric types
function update_all_rrd {
  local hostname=$1

  for metric_type in "${metric_list[@]}"
  do
    update_rrd "$hostname" "$metric_type"
  done
}


# returns the function name which returns the resource usage
# of the specified host
function get_resource_usage_function_name_by_metric_type {
  local hostname=$1
  local metric_type=$2
  # Check if the hostname is the physical host or a container
  if [ `hostname` != $hostname  ]; then
    echo "get_used_$metric_type"
  else
    echo "get_physical_used_$metric_type"
  fi
}


# starts to monitor the specified metric for the host
function start_update_rrd {
  local hostname=$1
  local metric_type=$2
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  if [ ! -f $database_file ]; then
    msg_error "Please create the $metric_type rrd for $hostname first. Aborting!"
    exit 1
  fi

  assert_metric "$metric_type"

  local monitor_update_conf=$(get_monitor_update_configuration_file "$hostname")

  get_monitor_configuration $hostname $metric_type
  # Remove cron job of host for metric_type if exists
  stop_update_rrd "$hostname" "$metric_type" > /dev/null
  #write out current crontab
  crontab -l > mycron
  #echo path variable to cron file if not set(this is for sbin directory due to zfs)
  local path_entry="PATH=\/usr\/local\/sbin:\/usr\/local\/bin:\/usr\/sbin:\/usr\/bin:\/sbin:\/bin"
  if ! grep -q "PATH=" mycron
  then
    sed -i "1s/^/$path_entry\n/" mycron
  fi

  get_monitor_update_configuration "$hostname"
  local monitor_update_conf=$(get_monitor_update_configuration_file "$hostname")
  local update_entry_in_configuration=$(get_update_entry_in_configuration "$hostname" "$metric_type")
  local value=$(get_update_entry_value_in_configuration $update_entry_in_configuration)

  if [ "$value" != "true" ]; then
    local entry="$update_entry_in_configuration=true"
    mkdir -p "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname"
    touch $monitor_update_conf
    echo "$entry" >> $monitor_update_conf
    msg_info "    - adding \"$entry\""
  fi

  #echo new cron into cron file if update entry does not exist
  local update_entry=$(get_update_entry $hostname)
  crontab -l | grep "$update_entry" > /dev/null
  local status=$?
  if [ $status != 0 ]; then
    echo "*/$(get_update_interval_in_minutes $hostname $metric_type) * * * * $update_entry" >> mycron
  fi

  #echo new cron into cron file if alert entry does not exist
  local alert_entry=$(get_alert_entry $hostname)
  crontab -l | grep "$alert_entry" > /dev/null
  local status=$?
  if [ $status != 0 ]; then
    echo "*/$(get_alert_interval_in_minutes $hostname $metric_type) * * * * $alert_entry" >> mycron
  fi
  #install new cron file
  crontab mycron
  rm mycron
}


# starts to monitor all the supported metrics for the host
function start_update_all_rrd {
  local hostname=$1

  for metric_type in "${metric_list[@]}"
  do
    start_update_rrd "$hostname" "$metric_type"
  done
}


# stops to monitor the specified metric for the host
function stop_update_rrd {
  local hostname=$1
  local metric_type=$2
  assert_metric "$metric_type"

  get_monitor_update_configuration "$hostname"
  local monitor_update_conf=$(get_monitor_update_configuration_file "$hostname")
  local update_entry_in_configuration=$(get_update_entry_in_configuration "$hostname" "$metric_type")
  local value=$(get_update_entry_value_in_configuration $update_entry_in_configuration)
  if [ "$value" == "true" ]; then
    local entry="$update_entry_in_configuration=true"
    sed -i "/$entry/d" $monitor_update_conf
    msg_info "    - removing \"$entry\""
    unset $update_entry_in_configuration
  fi

  if ! grep -q "true" "$monitor_update_conf" > /dev/null 2>&1; then
    local update_entry=$(get_update_entry $hostname)
    crontab -l | grep "$update_entry" > /dev/null
    local status=$?
    if [ $status == 0 ]; then
      msg_info "    - stop update job for $hostname"
      crontab -l | sed "/$update_entry/d" | crontab -
    fi

    local alert_entry=$(get_alert_entry $hostname)
    crontab -l | grep "$alert_entry" > /dev/null
    local status=$?
    if [ $status == 0 ]; then
      msg_info "    - stop alert job for $hostname"
      crontab -l | sed "/$alert_entry/d" | crontab -
    fi
  fi
}


# stops to monitor all the supported metrics for the host
function stop_update_all_rrd {
  local hostname=$1

  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  for metric_type in "${metric_list[@]}"
  do
    stop_update_rrd $hostname $metric_type
  done
}


# returns update entry of the metric for a given host inside crontab
function get_update_entry {
  local hostname=$1
  echo "subutai monitor -u all $hostname"
}


# returns alert entry of the metric for a given host inside crontab
function get_alert_entry {
  local hostname=$1
  echo "subutai monitor -a all $hostname"
}


function get_update_entry_in_configuration {
  local hostname=$1
  local metric_type=$2
  echo "$hostname"_"$metric_type""_update"
}


function get_update_entry_value_in_configuration {
  local update_entry_in_configuration=$1
  echo ${!update_entry_in_configuration}
}


# queries the rrd database of the metric of the specified host
function query_rrd {
  local hostname=$1
  local metric_type=$2
  
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi
  assert_metric "$metric_type"
  get_monitor_configuration $hostname $metric_type
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"

  local TIME=$(date +%s)
  local update_sequence=$(get_update_sequence $hostname $metric_type)
  # Show last X entries
  local maxSampleCount=$(get_max_sample_count)
  local start_time=$(($update_sequence * $maxSampleCount))

  if [ ! -f $database_file ]; then
    msg_error "Database file of $metric_type rrd for $hostname does not exist. Aborting!"
    exit 1
  fi

  rrdtool fetch "$database_file" LAST -e $TIME -s e-"$start_time"sec
}


# returns the resource of the specified metric for the specified PID
# inside the given container
function query_pid {
  local hostname=$1
  local metric_type=$2
  local pid=$3

  lxc_assert "$hostname" > /dev/null
  if [ "$metric_type" != "all"  ]; then
    assert_metric "$metric_type"
  fi
  assert_number "$pid"

  local print_result="{\"host\":\"$hostname\",\"pid\":\"$pid\""
  if [ $metric_type == "ram" ]; then
    local usage=$(get_ram_usage_in_bytes_by_pid $hostname $pid)
    print_result="$print_result, \"usedRam\":\"$usage\""
  elif [ $metric_type == "cpu" ]; then
    local usage=$(get_cpu_usage_percentage_by_pid $hostname $pid)
    print_result="$print_result, \"usedCpu\":\"$usage\""
  elif [ "$metric_type" == "all" ]; then
    local cpu_usage_percentage=$(get_cpu_usage_percentage_by_pid $hostname $pid)
    local ram_usage_in_bytes=$(get_ram_usage_in_bytes_by_pid $hostname $pid)
    print_result="$print_result, \"usedRam\":\"$ram_usage_in_bytes\""
    print_result="$print_result, \"usedCpu\":\"$cpu_usage_percentage\""
  else
    msg_error "$metric_type cannot be calculated for individual processes! Aborting.."
    exit 1
  fi
  print_result="$print_result}"
  echo "$print_result"
  return
}


# returns the resource of cpu metric in terms of percentage
# for the specified PID inside the given container
function get_cpu_usage_percentage_by_pid {
  local hostname=$1
  local pid=$2

  local usage_output=`lxc-attach -n "$hostname" -- ps -p $pid -o %cpu`
  local line_count=$(echo -e "$usage_output" | wc -l)

  if [ "$line_count" == "1" ]; then
    echo "0"
    return
  fi

  # since ps command is not cgroup aware, its percentage result does not
  # consider the quotas defined for the lxc container.
  # so we need to manipulate this result
  local usage_in_percentage_without_quotas=$(echo -e "$usage_output" | tail -1 | tr -d ' ')
  local cpu_quota=$(get_maximum_cpu_capacity_nanoseconds $hostname)
  local physical_cpu_capacity=$(get_physical_cpu_capacity_nanoseconds)
  local usage_in_percentage_with_quotas=$(echo "$usage_in_percentage_without_quotas*$cpu_quota*100/$physical_cpu_capacity" | bc)
  echo "$usage_in_percentage_with_quotas"
  return
}


# returns the resource of ram metric in terms of percentage
# for the specified PID inside the given container
function get_ram_usage_percentage_by_pid {
  local hostname=$1
  local pid=$2

  local usage_output=`lxc-attach -n "$hostname" -- ps -p $pid -o %mem`
  local line_count=$(echo -e "$usage_output" | wc -l)

  if [ "$line_count" == "1" ]; then
    echo "0"
    return
  fi

  local usage=$(echo -e "$usage_output" | tail -1 | tr -d ' ')
  echo "$usage"
}


# returns the resource of ram metric in terms of bytes
# for the specified PID inside the given container
function get_ram_usage_in_bytes_by_pid {
  local hostname=$1
  local pid=$2

  local usage_in_percentage=$(get_ram_usage_percentage_by_pid $hostname $pid)
  local ram_quota=$(get_total_ram $hostname)
  local usage_in_byte=$(echo $ram_quota*$usage_in_percentage/100 | bc)
  echo $usage_in_byte
}


# removes the rrd database and the related configuration files
# of the host for the given metric type
function destroy_monitor {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type"

  remove_monitor_configuration $hostname $metric_type
  remove_monitor_update_configuration "$hostname"
  remove_monitor_directory "$hostname"
  remove_rrd_file $hostname $metric_type
}


# destroys the monitoring related stuff for all the supported metrics
function destroy_all_monitor {
  local hostname=$1
  for metric_type in "${metric_list[@]}"
  do
    destroy_monitor $hostname $metric_type
  done
}


# removes the rrd database file of the host for the given metric type
function remove_rrd_file {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type" > /dev/null 2>&1

  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  stop_update_rrd $hostname $metric_type
  if [ -f $database_file ]; then
    rm -f $database_file
    msg_info "    - $metric_type rrd of $hostname is destroyed"
  fi
}


# remove configuration file of the host for the given metric type
function remove_monitor_configuration {
  local hostname=$1
  local metric_type=$2
  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type

  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
  if [ -f $monitor_conf ]; then
    rm -f $monitor_conf
    msg_info "    - $monitor_conf file is removed"
  fi
}


# remove update configuration file of the host for the given metric type
function remove_monitor_update_configuration {
  local hostname=$1
  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi

  local monitor_update_conf=$(get_monitor_update_configuration_file $hostname)
  if [ -f $monitor_update_conf ]; then
    rm -f $monitor_update_conf
    msg_info "    - $monitor_update_conf file is removed"
  fi
}


# remove monitor configuration directory for the given host
function remove_monitor_directory {
  local hostname=$1
  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi

  local monitor_conf_dir=$(get_monitor_configuration_dir $hostname)
  if [ -d $monitor_conf_dir ]; then
    rm -rf $monitor_conf_dir
    msg_info "    - $monitor_conf_dir directory is removed"
  fi
}

# exit if the provided metric is not in the predefined metric list
function assert_metric {
  local metric_type=$1
  if [ -z "$metric_type" ]; then
    msg_error "Metric type is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${metric_list[@]}" "$metric_type") != "y" ]; then
    msg_error "    - $metric_type is not supported metric type. Please provide one of the followings:"
    echo "      ${metric_list[@]}"
    exit 1
  fi
}


# exit if the provided dataset is not in the predefined dataset list
function assert_dataset {
  local dataset=$1
  if [ -z "$dataset" ]; then
    msg_error "Dataset is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${dataset_list[@]}" "$dataset") != "y" ]; then
    msg_error "    - $dataset is not supported dataset. Please provide one of the followings:"
    echo "      ${dataset_list[@]}"
    exit 1
  fi
}


# exit if the provided pool name is not in the predefined pool list 
function assert_pool {
  local pool_name=$1
  if [ -z "$pool_name" ]; then
    msg_error "Pool name is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${pool_list[@]}" "$pool_name") != "y" ]; then
    msg_error "    - $pool_name is not supported dataset. Please provide one of the followings:"
    echo "      ${pool_list[@]}"
    exit 1
  fi
}


# exit if all the parameters seperated by comma are not valid
function assert_parameters {
  local parameters=$1

  IFS=',' read -a parameterArray <<< "$parameters"
  for parameter in "${parameterArray[@]}"
  do
    assert_parameter $(echo $parameter | cut -d':' -f1)
  done
}


# exit if the provided parameter is not in the parameter list
function assert_parameter {
  local parameter=$1
  if [ -z "$parameter" ]; then
    msg_error "Parameter is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${parameter_list[@]}" "$parameter") != "y" ]; then
    msg_error "$parameter is not a supported parameter. Please provide one of the followings:"
    echo "${parameter_list[@]}"
    exit 1
  else
    msg_info "    - check passed: valid parameter \"$parameter\""
  fi
}


# returns the name of the dataset stored in the rrd database for the given metric type
function get_dataset_name {
  local metric_type=$1

  assert_metric "$metric_type"
  #TODO define datasets for each passed metric_type
  echo "$metric_type"_used
}


# returns the tag used for outputs such as in json key:value pairs
# for the given metric type
function get_metric_tag {
  local metric_type=$1

  assert_metric "$metric_type"
  # uppercase first character of the passed metric_type like ram to Ram
  local metric_type="$(tr '[:lower:]' '[:upper:]' <<< ${metric_type:0:1})${metric_type:1}"

  echo "used$metric_type"
}


# returns the database file name of host for the given metric type
function get_database_file {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type" > /dev/null

  echo ""$metric_type"_"$hostname".rrd"
}


# returns the update interval in minutes of the host for the given metric type
function get_update_interval_in_minutes {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  # Get configuration parameters
  get_monitor_configuration "$hostname" "$metric_type"

  if [ -z "$metricCollectionIntervalInMin" ]; then
    echo "1"
    return
  fi
  echo $metricCollectionIntervalInMin
  return
}


# returns the alert interval in minutes of the host for the given metric type
function get_alert_interval_in_minutes {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  # Get configuration parameters
  get_monitor_configuration "$hostname" "$metric_type"

  if [ -z "$intervalBetweenAlertsInMin" ]; then
    echo "10"
    return
  fi
  echo $intervalBetweenAlertsInMin
  return
}


# returns the update interval in seconds of the host for the given metric type
function get_update_sequence {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  local interval_in_minutes=$(get_update_interval_in_minutes $hostname $metric_type)
  echo "$(($interval_in_minutes * 60))"
}


# returns the maximum sample count to be stored of the host for the given metric type
function get_max_sample_count {
  if [ -z "$maxSampleCount" ]; then
    echo "1440"
    return
  fi
  echo $maxSampleCount
  return
}


# stores the passed parameters of the host for the given metric type in a configuration file
function store_monitor_configuration {
  local hostname=$1
  local metric_type=$2
  local parameters=$3
  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)

  if [[ -z "$parameters" ]]; then
    if [ -f $monitor_conf ]; then
      msg_info "    - using configuration file $monitor_conf"
    else
      msg_info "    - no parameters passed, default values are being used"
    fi
    return
  fi

  assert_no_config "$hostname" "$metric_type"
  assert_parameters "$parameters"

  IFS=',' read -a parameterArray <<< "$parameters"
  for parameter in "${parameterArray[@]}"
  do
    # Remove unnecessary whitespaces if any
    local parameter=$(echo " $parameter " | tr -d ' ')
    local value=$(echo $parameter | cut -d':' -f2)
    local numberExpression='^[0-9]+$'

    if [ -z "$value" ]; then
      msg_error "No value provided for $parameter! Aborting.."
      exit 1
    fi

    # Check if the value is a number
    if ! [[ $value =~ $numberExpression ]] ; then
      msg_error "$value is not a number! Aborting.."
      exit 1
    fi

    # Create the monitor conf directory if not created before
    mkdir -p "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname"
    touch $monitor_conf
    # Parse the parameter
    for supported_parameter in "${parameter_list[@]}"
    do
      if [[ $parameter == $supported_parameter:* ]]; then
	entry="export $supported_parameter=$value"
        echo "$entry" >> $monitor_conf
        msg_info "    - adding \"$entry\" into $metric_type configuration"
	break
      fi
    done
  done
  # Set the conf file to read only to disable user changes
  chmod 444 $monitor_conf

}


# loads the configuration parameters of the host for the given metric type 
# to the current shell session
function get_monitor_configuration {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type

  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
  # Inject the configurations if file exists
  if [ -f $monitor_conf ]; then
    . $monitor_conf
  fi
}


# loads the configuration parameters of the host for the given metric type
# to the current shell session
function get_monitor_update_configuration {
  local hostname=$1

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi

  local monitor_update_conf=$(get_monitor_update_configuration_file $hostname)
  # Inject the configurations if file exists
  if [ -f $monitor_update_conf ]; then
    . $monitor_update_conf
  fi
}


# returns the full path of the configuration file which keeps track of the metrics
# which are currently monitored of the host for the given metric type
function get_monitor_update_configuration_file {
  local hostname=$1

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi

  echo "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname/$hostname-monitor-update.conf"
  return
}


# returns the full path of the configuration file of the host for the given metric type
function get_monitor_configuration_file {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null 2>&1

  echo "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname/$hostname-$metric_type-monitor.conf"
  return
}


# returns the full path of the configuration directory of the host
function get_monitor_configuration_dir {
  local hostname=$1

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi

  echo "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname"
  return
}


# exit if there is configuration file of the host for the given metric type
function assert_no_config {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null 2>&1

  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
  if [ -f $monitor_conf ]; then
    msg_error "Configuration file of $metric_type already exists for $hostname! Aborting.."
    exit 1
  fi
}


# returns the ram threshold of the host
function get_ram_threshold_percentage {
  local hostname=$1
  # Get configuration parameters
  get_monitor_configuration "$hostname" "ram"

  if [ -z "$ramAlertThreshold" ]; then
    echo "80"
    return
  fi
  echo $ramAlertThreshold
  return
}


# returns the cpu threshold of the host
function get_cpu_threshold_percentage {
  local hostname=$1
  # Get configuration parameters
  get_monitor_configuration "$hostname" "cpu"

  if [ -z "$cpuAlertThreshold" ]; then
    echo "80"
    return
  fi
  echo $cpuAlertThreshold
  return
}


# returns the disk threshold of the host for the specified dataset
function get_disk_threshold_percentage {
  local hostname=$1
  local dataset=$2
  # Get configuration parameters
  get_monitor_configuration "$hostname" "$dataset"

  if [ -z "$diskAlertThreshold" ]; then
    echo "80"
    return
  fi
  echo $diskAlertThreshold
  return
}


# returns the metric count to average to trigger the alert
function get_metric_count_to_average_to_alert {
  local hostname=$1
  local metric_type=$2
  # Get configuration parameters
  get_monitor_configuration "$hostname" "$metric_type"

  if [ -z "$metricCountToAverageToAlert" ]; then
    echo "10"
    return
  fi
  echo $metricCountToAverageToAlert
  return
}


# returns the ram threshold in bytes to trigger the alert
function get_ram_alert_threshold_bytes {
  local lxc=$1
  local ram_threshold_percentage=$(get_ram_threshold_percentage $lxc)
  local ram_quota=$(get_total_ram $lxc)

  local result=$(echo $ram_quota*$ram_threshold_percentage/100 | bc)
  echo "$result"
  return
}


# returns the cpu threshold in nanoseconds to trigger the alert
function get_cpu_alert_threshold_nanoseconds {
  local lxc=$1
  local cpu_threshold_percentage=$(get_cpu_threshold_percentage $lxc)
  local cpu_quota=$(get_maximum_cpu_capacity_nanoseconds $lxc)

  local result=$(echo $cpu_quota*$cpu_threshold_percentage/100 | bc)
  echo "$result"
  return
}


# returns the disk threshold in bytes for the given dataset to trigger the alert
function get_disk_alert_threshold_bytes {
  local lxc=$1
  local dataset=$2
  local metric_type=$(get_disk_metric_type_by_dataset $dataset)
  local disk_threshold_percentage=$(get_disk_threshold_percentage $lxc $metric_type)
  local disk_quota=$(get_total_disk_by_dataset $lxc $dataset)

  local result=$(echo $disk_quota*$disk_threshold_percentage/100 | bc)
  echo "$result"
  return
}


# returns the metric type of the given dataset
function get_disk_metric_type_by_dataset {
  local dataset=$1
  echo "disk$(tr '[:lower:]' '[:upper:]' <<< ${dataset:0:1})${dataset:1}"
}


# make an alert for all the supported metrics
function alert_all_metrics {
  local hostname=$1
  ram_alert $hostname
  cpu_alert $hostname
  diskOpt_alert $hostname
  diskVar_alert $hostname
  diskHome_alert $hostname
  diskRootfs_alert $hostname
}


# make an alert if the ram threshold is exceeded by the given container
function ram_alert {
  local lxc=$1
  local metric_type="ram"
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $lxc $metric_type)"

  lxc_assert $lxc
  lxc_assert_running "$lxc"


  get_monitor_update_configuration "$lxc"
  local monitor_update_conf=$(get_monitor_update_configuration_file "$lxc")
  local update_entry_in_configuration=$(get_update_entry_in_configuration "$lxc" "$metric_type")
  local value=$(get_update_entry_value_in_configuration $update_entry_in_configuration)
  # exit if the metric of host is not set
  if [ "$value" != "true" ]; then
    msg_notice "    - $metric_type metric for $lxc is not enabled for monitoring, skipping alert..."
    return
  fi


  if [ ! -f $database_file ]; then
    msg_notice "    - Database file of $metric_type rrd for $lxc does not exist. Aborting!"
    return
  fi


  local ram_alert_threshold_bytes=$(get_ram_alert_threshold_bytes $lxc)
  local metricCountToAverageToAlert=$(get_metric_count_to_average_to_alert $lxc $metric_type)
  local average_used_ram=$(get_average_used_ram $lxc $metricCountToAverageToAlert)

  local last_N_values=$(query_rrd $lxc "$metric_type" | tail -$metricCountToAverageToAlert | grep "e+")
  if [ -z "$last_N_values" ]; then
    msg_notice "    - No data found for $metric_type metric for $lxc! Aborting.."
    return
  fi

  assert_number "$average_used_ram"
  assert_number "$ram_alert_threshold_bytes"

  if (( $(bc <<< "$average_used_ram >= $ram_alert_threshold_bytes") == 1 )); then
    msg_info "Ram alert threshold $ram_alert_threshold_bytes is exceeded with usage $average_used_ram($metricCountToAverageToAlert)!"
    local url=`build_rest_url monitor/alert`
    local current_metrics=$(subutai monitor $lxc)
    curl --data "metric=$current_metrics" "$url"
  else
    msg_info "Ram usage $average_used_ram($metricCountToAverageToAlert) is lower than threshold $ram_alert_threshold_bytes"
  fi
}


# make an alert if the cpu threshold is exceeded by the given container
function cpu_alert {
  local lxc=$1
  local metric_type="cpu"
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $lxc $metric_type)"

  lxc_assert "$lxc"
  lxc_assert_running "$lxc"


  get_monitor_update_configuration "$lxc"
  local monitor_update_conf=$(get_monitor_update_configuration_file "$lxc")
  local update_entry_in_configuration=$(get_update_entry_in_configuration "$lxc" "$metric_type")
  local value=$(get_update_entry_value_in_configuration $update_entry_in_configuration)
  # exit if the metric of host is not set
  if [ "$value" != "true" ]; then
    msg_notice "    - $metric_type metric for $lxc is not enabled for monitoring, skipping alert..."
    return
  fi

  if [ ! -f $database_file ]; then
    msg_notice "    - Database file of $metric_type rrd for $lxc does not exist. Aborting!"
    return
  fi

  local last_N_values=$(query_rrd $lxc "$metric_type" | tail -$metricCountToAverageToAlert | grep "e+")
  if [ -z "$last_N_values" ]; then
    msg_notice "    - No data found for $metric_type metric_type for $lxc! Aborting.."
    return
  fi

  local cpu_alert_threshold_nanoseconds=$(get_cpu_alert_threshold_nanoseconds $lxc)
  local metricCountToAverageToAlert=$(get_metric_count_to_average_to_alert $lxc $metric_type)
  local average_cpu_usage_between_samples=$(get_average_cpu_usage_between_samples $lxc $metricCountToAverageToAlert)

  assert_number "$average_cpu_usage_between_samples"
  assert_number "$cpu_alert_threshold_nanoseconds"

  if (( $(bc <<< "$cpu_alert_threshold_nanoseconds < $average_cpu_usage_between_samples") == 1 )); then
    msg_info "Cpu alert threshold $cpu_alert_threshold_nanoseconds is exceeded with usage $average_cpu_usage_between_samples($metricCountToAverageToAlert)!"
    local url=`build_rest_url monitor/alert`
    local current_metrics=$(subutai monitor $lxc)
    curl --data "metric=$current_metrics" "$url"
  else
    msg_info "Cpu usage $average_cpu_usage_between_samples($metricCountToAverageToAlert) is lower than threshold $cpu_alert_threshold_nanoseconds"
  fi
}


# make an alert if the disk threshold of the specified dataset is exceeded by the given container
function disk_alert {
  local lxc=$1
  local dataset=$2
  local metric_type=$(get_disk_metric_type_by_dataset $dataset)
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $lxc $metric_type)"

  lxc_assert $lxc
  lxc_assert_running "$lxc"


  get_monitor_update_configuration "$lxc"
  local monitor_update_conf=$(get_monitor_update_configuration_file "$lxc")
  local update_entry_in_configuration=$(get_update_entry_in_configuration "$lxc" "$metric_type")
  local value=$(get_update_entry_value_in_configuration $update_entry_in_configuration)
  # exit if the metric of host is not set
  if [ "$value" != "true" ]; then
    msg_notice "    - $metric_type metric for $lxc is not enabled for monitoring, skipping alert..."
    return
  fi

  if [ ! -f $database_file ]; then
    msg_notice "    - Database file of $metric_type rrd for $lxc does not exist, skippping.."
    return
  fi

  local disk_alert_threshold_bytes=$(get_disk_alert_threshold_bytes $lxc $dataset)
  local metricCountToAverageToAlert=$(get_metric_count_to_average_to_alert $lxc $metric_type)
  local average_used_disk=$(get_average_used_disk_by_metric_type $lxc $metric_type $metricCountToAverageToAlert)

  local last_N_values=$(query_rrd $lxc "$metric_type" | tail -$metricCountToAverageToAlert | grep "e+")
  if [ -z "$last_N_values" ]; then
    msg_notice "    - No data found for $metric_type metric for $lxc, skipping.."
    return
  fi

  assert_number "$average_used_disk"
  assert_number "$disk_alert_threshold_bytes"

  if (( $(bc <<< "$average_used_disk >= $disk_alert_threshold_bytes") == 1 )); then
    msg_info "$metric_type alert threshold $disk_alert_threshold_bytes is exceeded with usage $average_used_disk($metricCountToAverageToAlert)!"
    local url=`build_rest_url monitor/alert`
    local current_metrics=$(subutai monitor $lxc)
    curl --data "metric=$current_metrics" "$url"
  else
    msg_info "$metric_type usage $average_used_disk($metricCountToAverageToAlert) is lower than threshold $disk_alert_threshold_bytes"
  fi
}


# make an alert if the disk threshold of the "opt" dataset is exceeded by the given container
function diskOpt_alert {
  local lxc=$1
  local dataset="opt"
  disk_alert $lxc $dataset
}


# make an alert if the disk threshold of the "var" dataset is exceeded by the given container
function diskVar_alert {
  local lxc=$1
  local dataset="var"
  disk_alert $lxc $dataset
}


# make an alert if the disk threshold of the "home" dataset is exceeded by the given container
function diskHome_alert {
  local lxc=$1
  local dataset="home"
  disk_alert $lxc $dataset
}


# make an alert if the disk threshold of the "rootfs" dataset is exceeded by the given container
function diskRootfs_alert {
  local lxc=$1
  local dataset="rootfs"
  disk_alert $lxc $dataset
}


# exit if the variable is not a number
function assert_number {
  local variable="$1"
  local numberExpression='^[0-9]+$'
  if [ -z "$variable" ]; then
    msg_error "Variable asserted to be a number is empty! Aborting.."
    exit 1
  fi
  # Check if the value is a number
  if ! [[ $variable =~ $numberExpression ]] ; then
    msg_error "$variable is not a number! Aborting.."
    exit 1
  fi
}


# returns "true" if the variable is a number
# returns "false" if the variable is not a number
function is_number {
  local variable="$1"
  local numberExpression='^[0-9]+$'
  if [ -z "$variable" ]; then
    echo "false"
    return
  fi

  if ! [[ $variable =~ $numberExpression ]] ; then
    echo "false"
    return
  fi

  echo "true"
  return
}


# returns human readable output for the provided byte value
# note: it appends B|K|M|G|T|P|E to the output
function get_readable_output_from_byte {
  local bytes=$1
  assert_number $bytes
  local precision_count=2
  local kilobytes=$(echo "scale=$precision_count; $bytes/1024" | bc)
  local megabytes=$(echo "scale=$precision_count; $kilobytes/1024" | bc)
  local gigabytes=$(echo "scale=$precision_count; $megabytes/1024" | bc)
  local terabytes=$(echo "scale=$precision_count; $gigabytes/1024" | bc)
  local petabytes=$(echo "scale=$precision_count; $terabytes/1024" | bc)
  local exabytes=$(echo "scale=$precision_count; $petabytes/1024" | bc)

  if (( $(bc <<< "$bytes <= 1024") == 1 )); then
    echo $bytes"B"
  elif (( $(bc <<< "$kilobytes <= 1024") == 1 )); then
    echo $kilobytes"K"
  elif (( $(bc <<< "$megabytes <= 1024") == 1 )); then
    echo $megabytes"M"
  elif (( $(bc <<< "$gigabytes <= 1024") == 1 )); then
    echo $gigabytes"G"
  elif (( $(bc <<< "$terabytes <= 1024") == 1 )); then
    echo $terabytes"T"
  elif (( $(bc <<< "$petabytes <= 1024") == 1 )); then
    echo $petabytes"P"
  else (( $(bc <<< "$exabytes <= 1024") == 1 ))
    echo $exabytes"E"
  fi
  return
}


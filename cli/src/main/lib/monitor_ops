#!/bin/bash

# ==========================================================================
# Set of functions for monitoring functionality
# ==========================================================================

metric_list=("ram" "cpu" "diskVar" "diskOpt" "diskHome" "diskRootfs")
dataset_list=("var" "opt" "home" "rootfs")
pool_list=("lxc" "lxc-data")
parameter_list=("metricCollectionIntervalInMin" "maxSampleCount" "metricCountToAverageToAlert" "intervalBetweenAlertsInMin" "ramAlertThreshold" "cpuAlertThreshold" "diskAlertThreshold")


function get_total_ram {
  local lxc="$1"
  lxc_assert $lxc > /dev/null

  local physical_total_ram=$(get_physical_total_ram)
  local ram_quota=$(lxc_get_memory $lxc)
  assert_number "$ram_quota"  > /dev/null

  if (( $(bc <<< "$ram_quota <= $physical_total_ram") == 1 )); then
    echo "$ram_quota"
    return
  fi
  echo "$physical_total_ram"
  return
}


# Returns maximum cpu time can be used within
# one second in terms of nanoseconds
function get_maximum_cpu_capacity_nanoseconds {
  local lxc="$1"
  lxc_assert $lxc > /dev/null

  local cfs_quota=$(lxc_get_cfs_quota $lxc)
  local cfs_period=$(lxc_get_cfs_period $lxc)
  local seconds_to_nanoseconds="1000000000"

  # Check if there is no quota set for lxc
  if [ "$cfs_quota" == -1 ]; then
    local cpu_core_quota=$(lxc_get_cpu_core_count $lxc)
    local result=$(echo $cpu_core_quota*$seconds_to_nanoseconds | bc)
    echo "$result"
    return
  fi

  local result=$(echo $cfs_quota/$cfs_period*$seconds_to_nanoseconds | bc)
  echo "$result"
  return
}


function get_available_ram {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  local ram_quota=$(lxc_get_memory $lxc)
  local total_available_ram=$(get_physical_available_ram)
  local physical_total_ram=$(get_physical_total_ram)

  # return available ram for container if there is a limit set
  if (( $(bc <<< "$ram_quota < $physical_total_ram") == 1 )); then
    local used_ram=$(get_used_ram $lxc)
    local available_ram=$(($ram_quota - $used_ram))
    # TODO does this manipulation necessary?
    # check if available ram is greater than physical resource host's available ram
#    if [[ "$available_ram" -gt "$total_available_ram" ]]; then
#      echo $total_available_ram
#      return
#    fi
    echo $available_ram
    return
  fi
  # else return total available ram
  echo $total_available_ram
  return
}


function get_used_ram {
  local lxc=$1
  lxc_assert $lxc > /dev/null

  local used_ram=$(cat /sys/fs/cgroup/memory/lxc/$lxc/memory.usage_in_bytes)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_ram
    return
  fi
  echo 0
  return
}


function get_average_used_ram {
  local lxc=$1
  local sampleCountToAverage=$2
  local metric_type="ram"
  get_metric_average $lxc $sampleCountToAverage $metric_type
}


function get_average_cpu_usage_between_samples {
  local lxc=$1
  local sampleCountToAverage=$2
  local metric_type="cpu"

  lxc_assert $lxc > /dev/null
  local numberExpression='^[0-9]+$'

  if [ -z "$sampleCountToAverage" ]; then
    msg_error "No value provided for sampleCountToAverage! Aborting.."
    exit 1
  fi

  # Check if the value is a number
  if ! [[ $sampleCountToAverage =~ $numberExpression ]] ; then
    msg_error "$sampleCountToAverage is not a number! Aborting.."
    exit 1
  fi

  assert_metric $metric_type > /dev/null

  local cpu_values=$(query_rrd $lxc "$metric_type" | tail -$(($sampleCountToAverage + 1)) | grep "e+")
  local line_count=$(echo -e "$cpu_values" | wc -l)

  if [ $line_count -lt 2 ]; then
    echo "0"
    return
  fi
  local first_value=$(echo -e "$cpu_values" | sed -n 1p | cut -d':' -f2 | tr -d ' ' | sed -e 's/[eE]+*/*10^/')
  local last_value=$(echo -e "$cpu_values" | sed -e '$!d' | cut -d':' -f2 | tr -d ' ' | sed -e 's/[eE]+*/*10^/')

  local cpu_usage=$(echo $last_value - $first_value | bc)
  # Remove insignificant bits
  cpu_usage=$(echo $cpu_usage | cut -d'.' -f1)

  if [ -z "$cpu_usage" ]; then
    echo "0"
    return
  fi

  if (( $(bc <<< "$last_value <= $first_value") == 1 )); then
    echo "0"
    return
  fi

  local update_sequence=$(get_update_sequence $lxc $metric_type)
  if [ $line_count -lt $sampleCountToAverage  ]; then
    sampleCountToAverage=$(($line_count - 1))
  fi
#  msg_debug "first_value: $first_value"
#  msg_debug "last_value:  $last_value"
#  msg_debug "line_count:  $line_count"
#  msg_debug "sampleCount: $sampleCountToAverage"
  echo $(($cpu_usage / $sampleCountToAverage / $update_sequence))
  return
}


function get_metric_average {
  local lxc=$1
  local sampleCountToAverage=$2
  local metric_type=$3

  lxc_assert $lxc > /dev/null
  local numberExpression='^[0-9]+$'

  if [ -z "$sampleCountToAverage" ]; then
    msg_error "No value provided for sampleCountToAverage! Aborting.."
    exit 1
  fi

  # Check if the value is a number
  if ! [[ $sampleCountToAverage =~ $numberExpression ]] ; then
    msg_error "$sampleCountToAverage is not a number! Aborting.."
    exit 1
  fi

  if [ $sampleCountToAverage -lt 1 ]; then
    msg_error "Sample count to be averaged cannot be less than \"1\". Aborting!"
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  local maxSampleCount=$(get_max_sample_count)
  if [ $sampleCountToAverage -gt $maxSampleCount ]; then
    msg_error "Sample count cannot be greater than maximum sample count! Aborting.."
    exit 1
  fi

  local last_N_values=$(query_rrd $lxc "$metric_type" | tail -$sampleCountToAverage | grep "e+")
  if [ -z "$last_N_values" ]; then
    msg_error "No data found for $metric_type metric_type for $lxc! Aborting.."
    exit 1
  fi

  local sum=$(echo "0" | bc)
  local line_count=$(echo "$last_N_values" | wc -l)
  while read -r line; do
    value=$(echo $line | cut -d':' -f2 | tr -d ' ' | sed -e 's/[eE][+][0]/*10^/')
    sum=$(echo $sum+$value | bc)
  done <<< "$last_N_values"
  # Remove insignificant bits
  sum=$(echo $sum | cut -d'.' -f1)
  if [ -z "$sum" ]; then
    echo "0"
    return
  fi
  echo $(($sum / $line_count))
  return
}


# reports the total CPU time (in nanoseconds) consumed by all tasks in this cgroup
function get_used_cpu {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  
  local used_cpu=$(cat /sys/fs/cgroup/cpuacct/lxc/$lxc/cpuacct.usage)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_cpu
  fi
}


function get_physical_total_ram {
  local total_ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  echo "$(($total_ram_kb * 1024))"
  return
}


function get_physical_available_ram {
  local total_ram=$(get_physical_total_ram)
  local used_ram=$(get_physical_used_ram)
  echo "$(($total_ram - $used_ram))"
  return
}


function get_physical_used_ram {
  local used_ram=$(cat /sys/fs/cgroup/memory/memory.usage_in_bytes)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_ram
  fi
}


# reports the total CPU time (in nanoseconds) consumed by all tasks in this cgroup
function get_physical_used_cpu {
  local used_cpu=$(cat /sys/fs/cgroup/cpuacct/cpuacct.usage)
  local status=$?

  if [ $status == 0 ]; then
    echo $used_cpu
  fi
}


function get_available_disk_by_dataset {
  local lxc=$1
  local dataset=$2
  lxc_assert $lxc > /dev/null
  assert_dataset $dataset
  echo $(fs_get_available_disk "$lxc" "$dataset")
}


function get_available_disk_var {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "var")
}


function get_available_disk_opt {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "opt")
}


function get_available_disk_home {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "home")
}


function get_available_disk_rootfs {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_available_disk_by_dataset "$lxc" "rootfs")
}


function get_used_disk_by_dataset {
  local lxc=$1
  local dataset=$2
  lxc_assert $lxc > /dev/null
  assert_dataset $dataset
  echo $(fs_get_used_disk "$lxc" "$dataset")
}


function get_used_disk_var {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "var")
}


function get_used_disk_opt {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "opt")
}


function get_used_disk_home {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "home")
}


function get_used_disk_rootfs {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_used_disk_by_dataset "$lxc" "rootfs")
}


function get_total_disk_by_dataset {
  local lxc=$1
  local dataset=$2
  assert_dataset $dataset

  local disk_quota=$(fs_get_quota $lxc | grep "$dataset" | cut -d':' -f2 | tr -d '\040\011\015')
  local physical_total_disk_dataset=$(get_physical_total_disk_"$dataset")
  local numberExpression='^[0-9]+$'

  if [ -z "$disk_quota" ]; then
    echo "$physical_total_disk_dataset"
    return
  fi
  # Check if the value is a number
  if ! [[ $disk_quota =~ $numberExpression ]] ; then
    echo "$physical_total_disk_dataset"
    return
  fi

  assert_number "$disk_quota"  > /dev/null

  if (( $(bc <<< "$disk_quota <= $physical_total_disk_dataset") == 1 )); then
    echo "$disk_quota"
    return
  fi
  echo "$physical_total_disk_dataset"
  return
}


function get_total_disk_var {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "var")
}


function get_total_disk_opt {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "opt")
}


function get_total_disk_home {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "home")
}


function get_total_disk_rootfs {
  local lxc=$1
  lxc_assert $lxc > /dev/null
  echo $(get_total_disk_by_dataset "$lxc" "rootfs")
}


function get_var_dataset_pool {
  echo "lxc-data"
}


function get_opt_dataset_pool {
  echo "lxc"
}


function get_home_dataset_pool {
  echo "lxc-data"
}


function get_rootfs_dataset_pool {
  echo "lxc"
}


function get_physical_available_disk_by_pool_name {
  local pool_name=$1
  assert_pool $pool_name
  echo $(fs_get_physical_available_disk "$pool_name")
}


function get_physical_available_disk_var {
  local pool=$(get_var_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


function get_physical_available_disk_opt {
  local pool=$(get_opt_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


function get_physical_available_disk_home {
  local pool=$(get_home_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


function get_physical_available_disk_rootfs {
  local pool=$(get_rootfs_dataset_pool)
  get_physical_available_disk_by_pool_name $pool
}


function get_physical_used_disk_by_pool_name {
  local pool_name=$1
  assert_pool $pool_name
  echo $(fs_get_physical_used_disk "$pool_name")
}


function get_physical_used_disk_var {
  local pool=$(get_var_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


function get_physical_used_disk_opt {
  local pool=$(get_opt_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


function get_physical_used_disk_home {
  local pool=$(get_home_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


function get_physical_used_disk_rootfs {
  local pool=$(get_rootfs_dataset_pool)
  get_physical_used_disk_by_pool_name $pool
}


function get_physical_total_disk_by_pool_name {
  local pool_name=$1
  assert_pool $pool
  echo $(fs_get_physical_total_disk $pool_name)
  return
}


function get_physical_total_disk_var {
  local pool=$(get_var_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


function get_physical_total_disk_opt {
  local pool=$(get_opt_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


function get_physical_total_disk_home {
  local pool=$(get_home_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


function get_physical_total_disk_rootfs {
  local pool=$(get_rootfs_dataset_pool)
  get_physical_total_disk_by_pool_name $pool
}


function contains() {
    local n=$#
    local value=${!n}
    for ((i=1;i < $#;i++)) {
        if [ "${!i}" == "${value}" ]; then
            echo "y"
            return 0
        fi
    }
    echo "n"
    return 1
}


function create_rrd {
  local hostname=$1
  local metric_type=$2
  local parameters=$3
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  mkdir -p $SUBUTAI_RRD_DIRECTORY > /dev/null 2>&1
  assert_metric "$metric_type"

  local database_file=$(get_database_file $hostname $metric_type)
  local dataset_name=$(get_dataset_name $metric_type)

  if [ -f $SUBUTAI_RRD_DIRECTORY/$database_file ]; then
    msg_notice "    - $database_file already exists, skipping..."
    start_update_rrd "$hostname" "$metric_type" > /dev/null
    return
  fi

  # Assert no config file exists if parameter is passed
  if [ -n "$parameters" ]; then
    local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
    if [ -f $monitor_conf ]; then
      msg_notice "    - configuration file of $metric_type already exists for $hostname! Using existing configuration.."
    else
      # Save parameters inside configuration file
      store_monitor_configuration "$hostname" "$metric_type" "$parameters"
    fi
  fi

  # Setup configurations of monitoring infrastructure for host
  get_monitor_configuration "$hostname" "$metric_type"

  # Initialize following variables that depend on configuration file
  # after get_monitor_configuration call
  local update_sequence=$(get_update_sequence $hostname $metric_type)
  local maxSampleCount=$(get_max_sample_count)

  pushd $SUBUTAI_RRD_DIRECTORY > /dev/null

  rrdtool create "$database_file" --no-overwrite --step $update_sequence DS:"$dataset_name":GAUGE:$(($update_sequence * 2 - 1)):0:U RRA:LAST:0.5:1:$maxSampleCount
  msg_info "    - $metric_type rrd is created for $hostname"
  popd > /dev/null
  start_update_rrd "$hostname" "$metric_type" > /dev/null
}


function create_all_rrd {
  local hostname=$1
  local parameters=$2

  for metric_type in "${metric_list[@]}"
  do
    create_rrd "$hostname" "$metric_type" "$parameters"
  done
}


function update_rrd {
  local hostname=$1
  local metric_type=$2

  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  assert_metric "$metric_type"
  get_monitor_configuration "$hostname" "$metric_type"
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  local tag=$(get_metric_tag $metric_type)
  local dataset_name=$(get_dataset_name $metric_type)
  local update_sequence=$(get_update_sequence $hostname $metric_type)
  local metric_value=$(subutai monitor $hostname | awk -F"$tag" '{print $2}' | awk -F"," '{print $1}' | awk -F"\"" '{print $3}')

  msg_info "    - $metric_value is stored at `date +%s`"
  rrdtool update  "$database_file" --template "$dataset_name" N:"$metric_value"
}


function start_update_rrd {
  local hostname=$1
  local metric_type=$2
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  if [ ! -f $database_file ]; then
    msg_error "Please create the $metric_type rrd for $hostname first. Aborting!"
    exit 1
  fi

  assert_metric "$metric_type"
  get_monitor_configuration $hostname $metric_type
  # Remove cron job of host for metric_type if exists
  stop_update_rrd "$hostname" "$metric_type" > /dev/null
  #write out current crontab
  crontab -l > mycron
  #echo new cron into cron file
  local update_entry=$(get_update_entry $hostname $metric_type)
  echo "*/$(get_update_interval_in_minutes $hostname $metric_type) * * * * $update_entry" >> mycron
  #echo new cron into cron file
  local alert_entry=$(get_alert_entry $hostname $metric_type)
  echo "*/$(get_alert_interval_in_minutes $hostname $metric_type) * * * * $alert_entry" >> mycron
  #install new cron file
  crontab mycron
  rm mycron


}


function start_update_all_rrd {
  local hostname=$1

  for metric_type in "${metric_list[@]}"
  do
    start_update_rrd "$hostname" "$metric_type"
  done
}


function stop_update_rrd {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type"
  local update_entry=$(get_update_entry $hostname $metric_type)
  crontab -l | grep "$update_entry" > /dev/null
  local status=$?
  if [ $status == 0 ]; then
    msg_info "    - stop update job of $metric_type metric for $hostname"
    crontab -l | sed "/$update_entry/d" | crontab -
  fi

  local alert_entry=$(get_alert_entry $hostname $metric_type)
  crontab -l | grep "$alert_entry" > /dev/null
  local status=$?
  if [ $status == 0 ]; then
    msg_info "    - stop alert job of $metric_type metric for $hostname"
    crontab -l | sed "/$alert_entry/d" | crontab -
  fi
}


function stop_update_all_rrd {
  local hostname=$1

  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi

  for metric_type in "${metric_list[@]}"
  do
    stop_update_rrd $hostname $metric_type > /dev/null
  done
}


function get_update_entry {
  local hostname=$1
  local metric_type=$2
  echo "subutai monitor -u $metric_type $hostname"
}


function get_alert_entry {
  local hostname=$1
  local metric_type=$2
  echo "subutai monitor -a $metric_type $hostname"
}


function query_rrd {
  local hostname=$1
  local metric_type=$2
  
  if [ `hostname` != $hostname ]; then
    lxc_assert "$hostname"
  fi
  assert_metric "$metric_type"
  get_monitor_configuration $hostname $metric_type
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"

  local TIME=$(date +%s)
  local update_sequence=$(get_update_sequence $hostname $metric_type)
  # Show last X entries
  local maxSampleCount=$(get_max_sample_count)
  local start_time=$(($update_sequence * $maxSampleCount))

  if [ ! -f $database_file ]; then
    msg_error "Database file of $metric_type rrd for $hostname does not exist. Aborting!"
    exit 1
  fi

  rrdtool fetch "$database_file" LAST -e $TIME -s e-"$start_time"sec
}


function destroy_monitor {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type"

  remove_monitor_configuration $hostname $metric_type
  remove_rrd_file $hostname $metric_type
}


function destroy_all_monitor {
  local hostname=$1
  for metric_type in "${metric_list[@]}"
  do
    destroy_monitor $hostname $metric_type
  done
}


function remove_rrd_file {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type" > /dev/null 2>&1

  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $hostname $metric_type)"
  stop_update_rrd $hostname $metric_type
  if [ -f $database_file ]; then
    rm -f $database_file
    msg_info "    - $metric_type rrd of $hostname is destroyed"
  fi
}


function remove_monitor_configuration {
  local hostname=$1
  local metric_type=$2
  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type

  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
  if [ -f $monitor_conf ]; then
    rm -f $monitor_conf
    msg_info "    - $monitor_conf file is removed"
  fi
}


function assert_metric {
  local metric_type=$1
  if [ -z "$metric_type" ]; then
    msg_error "Metric type is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${metric_list[@]}" "$metric_type") != "y" ]; then
    msg_error "    - $metric_type is not supported metric type. Please provide one of the followings:"
    echo "      ${metric_list[@]}"
    exit 1
  fi
}


function assert_dataset {
  local dataset=$1
  if [ -z "$dataset" ]; then
    msg_error "Dataset is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${dataset_list[@]}" "$dataset") != "y" ]; then
    msg_error "    - $dataset is not supported dataset. Please provide one of the followings:"
    echo "      ${dataset_list[@]}"
    exit 1
  fi
}


function assert_pool {
  local pool_name=$1
  if [ -z "$pool_name" ]; then
    msg_error "Pool name is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${pool_list[@]}" "$pool_name") != "y" ]; then
    msg_error "    - $pool_name is not supported dataset. Please provide one of the followings:"
    echo "      ${pool_list[@]}"
    exit 1
  fi
}


function assert_parameters {
  local parameters=$1

  IFS=',' read -a parameterArray <<< "$parameters"
  for parameter in "${parameterArray[@]}"
  do
    assert_parameter $(echo $parameter | cut -d':' -f1)
  done
}


function assert_parameter {
  local parameter=$1
  if [ -z "$parameter" ]; then
    msg_error "Parameter is empty. Aborting!"
    exit 1
  fi

  if [ $(contains "${parameter_list[@]}" "$parameter") != "y" ]; then
    msg_error "$parameter is not a supported parameter. Please provide one of the followings:"
    echo "${parameter_list[@]}"
    exit 1
  else
    msg_info "    - check passed: valid parameter \"$parameter\""
  fi
}


function get_dataset_name {
  local metric_type=$1

  assert_metric "$metric_type"
  #TODO define datasets for each passed metric_type
  echo "$metric_type"_used
}


function get_metric_tag {
  local metric_type=$1

  assert_metric "$metric_type"
  # uppercase first character of the passed metric_type like ram to Ram
  local metric_type="$(tr '[:lower:]' '[:upper:]' <<< ${metric_type:0:1})${metric_type:1}"

  echo "used$metric_type"
}


function get_database_file {
  local hostname=$1
  local metric_type=$2

  assert_metric "$metric_type" > /dev/null

  echo ""$metric_type"_"$hostname".rrd"
}


function get_update_interval_in_minutes {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  # Get configuration parameters
  get_monitor_configuration "$hostname" "$metric_type"

  if [ -z "$metricCollectionIntervalInMin" ]; then
    echo "1"
    return
  fi
  echo $metricCollectionIntervalInMin
  return
}


function get_alert_interval_in_minutes {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  # Get configuration parameters
  get_monitor_configuration "$hostname" "$metric_type"

  if [ -z "$intervalBetweenAlertsInMin" ]; then
    echo "10"
    return
  fi
  echo $intervalBetweenAlertsInMin
  return
}


function get_update_sequence {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null

  local interval_in_minutes=$(get_update_interval_in_minutes $hostname $metric_type)
  echo "$(($interval_in_minutes * 60))"
}


function get_max_sample_count {
  if [ -z "$maxSampleCount" ]; then
    echo "1440"
    return
  fi
  echo $maxSampleCount
  return
}


function store_monitor_configuration {
  local hostname=$1
  local metric_type=$2
  local parameters=$3
  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)

  if [[ -z "$parameters" ]]; then
    if [ -f $monitor_conf ]; then
      msg_info "    - using configuration file $monitor_conf"
    else
      msg_info "    - no parameters passed, default values are being used"
    fi
    return
  fi

  assert_no_config "$hostname" "$metric_type"
  assert_parameters "$parameters"

  IFS=',' read -a parameterArray <<< "$parameters"
  for parameter in "${parameterArray[@]}"
  do
    # Remove unnecessary whitespaces if any
    local parameter=$(echo " $parameter " | tr -d ' ')
    local value=$(echo $parameter | cut -d':' -f2)
    local numberExpression='^[0-9]+$'

    if [ -z "$value" ]; then
      msg_error "No value provided for $parameter! Aborting.."
      exit 1
    fi

    # Check if the value is a number
    if ! [[ $value =~ $numberExpression ]] ; then
      msg_error "$value is not a number! Aborting.."
      exit 1
    fi

    # Create the monitor conf directory if not created before
    mkdir -p "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname"
    touch $monitor_conf
    # Parse the parameter
    for supported_parameter in "${parameter_list[@]}"
    do
      if [[ $parameter == $supported_parameter:* ]]; then
	entry="export $supported_parameter=$value"
        echo "$entry" >> $monitor_conf
        msg_info "    - adding \"$entry\" into $metric_type configuration"
	break
      fi
    done
  done
  # Set the conf file to read only to disable user changes
  chmod 444 $monitor_conf

}


function get_monitor_configuration {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type

  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
  # Inject the configurations if file exists
  if [ -f $monitor_conf ]; then
    . $monitor_conf
  fi
}


function get_monitor_configuration_file {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null 2>&1

  echo "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname/$hostname-$metric_type-monitor.conf"
  return
}


function get_monitor_configuration_dir {
  local hostname=$1

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi

  echo "$SUBUTAI_MONITOR_CONF_DIRECTORY/$hostname"
  return
}


function assert_no_config {
  local hostname=$1
  local metric_type=$2

  if [ -z "$hostname" ]; then
    msg_error "Hostname information not provided to ${FUNCNAME[0]}! Aborting.."
    exit 1
  fi
  assert_metric $metric_type > /dev/null 2>&1

  local monitor_conf=$(get_monitor_configuration_file $hostname $metric_type)
  if [ -f $monitor_conf ]; then
    msg_error "Configuration file of $metric_type already exists for $hostname! Aborting.."
    exit 1
  fi
}


function get_ram_threshold_percentage {
  local hostname=$1
  # Get configuration parameters
  get_monitor_configuration "$hostname" "ram"

  if [ -z "$ramAlertThreshold" ]; then
    echo "80"
    return
  fi
  echo $ramAlertThreshold
  return
}


function get_cpu_threshold_percentage {
  local hostname=$1
  # Get configuration parameters
  get_monitor_configuration "$hostname" "cpu"

  if [ -z "$cpuAlertThreshold" ]; then
    echo "80"
    return
  fi
  echo $cpuAlertThreshold
  return
}


function get_disk_threshold_percentage {
  local hostname=$1
  # Get configuration parameters
  get_monitor_configuration "$hostname" "disk"

  if [ -z "$diskAlertThreshold" ]; then
    echo "80"
    return
  fi
  echo $diskAlertThreshold
  return
}


function get_metric_count_to_average_to_alert {
  local hostname=$1
  local metric_type=$2
  # Get configuration parameters
  get_monitor_configuration "$hostname" "$metric_type"

  if [ -z "$metricCountToAverageToAlert" ]; then
    echo "10"
    return
  fi
  echo $metricCountToAverageToAlert
  return
}


function get_ram_alert_threshold_bytes {
  local lxc=$1
  local ram_threshold_percentage=$(get_ram_threshold_percentage $lxc)
  local ram_quota=$(get_total_ram $lxc)

  local result=$(echo $ram_quota*$ram_threshold_percentage/100 | bc)
  echo "$result"
  return
}


function get_cpu_alert_threshold_nanoseconds {
  local lxc=$1
  local cpu_threshold_percentage=$(get_cpu_threshold_percentage $lxc)
  local cpu_quota=$(get_maximum_cpu_capacity_nanoseconds $lxc)

  local result=$(echo $cpu_quota*$cpu_threshold_percentage/100 | bc)
  echo "$result"
  return
}


function ram_alert {
  local lxc=$1
  local metric_type="ram"
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $lxc $metric_type)"

  lxc_assert $lxc
  lxc_assert_running "$lxc"

  if [ ! -f $database_file ]; then
    msg_error "Database file of $metric_type rrd for $lxc does not exist. Aborting!"
    exit 1
  fi


  local ram_alert_threshold_bytes=$(get_ram_alert_threshold_bytes $lxc)
  local metricCountToAverageToAlert=$(get_metric_count_to_average_to_alert $lxc $metric_type)
  local average_used_ram=$(get_average_used_ram $lxc $metricCountToAverageToAlert)

  local last_N_values=$(query_rrd $lxc "$metric_type" | grep "e+" |tail -$metricCountToAverageToAlert)
  if [ -z "$last_N_values" ]; then
    msg_error "No data found for $metric_type metric for $lxc! Aborting.."
    exit 1
  fi

  assert_number "$average_used_ram"
  assert_number "$ram_alert_threshold_bytes"

  if (( $(bc <<< "$average_used_ram >= $ram_alert_threshold_bytes") == 1 )); then
    msg_info "Ram alert threshold $ram_alert_threshold_bytes is exceeded with usage $average_used_ram($metricCountToAverageToAlert)!"
    local url=`build_rest_url monitor/alert`
    local current_metrics=$(subutai monitor $lxc)
    curl --data "$current_metrics" "$url"
  else
    msg_info "Ram usage $average_used_ram($metricCountToAverageToAlert) is lower than threshold $ram_alert_threshold_bytes"
  fi
}


function cpu_alert {
  local lxc=$1
  local metric_type="cpu"
  local database_file="$SUBUTAI_RRD_DIRECTORY/$(get_database_file $lxc $metric_type)"

  lxc_assert "$lxc"
  lxc_assert_running "$lxc"

  if [ ! -f $database_file ]; then
    msg_error "Database file of $metric_type rrd for $lxc does not exist. Aborting!"
    exit 1
  fi

  local cpu_alert_threshold_nanoseconds=$(get_cpu_alert_threshold_nanoseconds $lxc)
  local metricCountToAverageToAlert=$(get_metric_count_to_average_to_alert $lxc $metric_type)
  local average_cpu_usage_between_samples=$(get_average_cpu_usage_between_samples $lxc $metricCountToAverageToAlert)


  local last_N_values=$(query_rrd $lxc "$metric_type" | grep "e+" |tail -$metricCountToAverageToAlert)
  if [ -z "$last_N_values" ]; then
    msg_error "No data found for $metric_type metric_type for $lxc! Aborting.."
    exit 1
  fi

  assert_number "$average_cpu_usage_between_samples"
  assert_number "$cpu_alert_threshold_nanoseconds"

  if (( $(bc <<< "$cpu_alert_threshold_nanoseconds < $average_cpu_usage_between_samples") == 1 )); then
    msg_info "Cpu alert threshold $cpu_alert_threshold_nanoseconds is exceeded with usage $average_cpu_usage_between_samples($metricCountToAverageToAlert)!"
    local url=`build_rest_url monitor/alert`
    local current_metrics=$(subutai monitor $lxc)
    curl --data "$current_metrics" "$url"
  else
    msg_info "Cpu usage $average_cpu_usage_between_samples($metricCountToAverageToAlert) is lower than threshold $cpu_alert_threshold_nanoseconds"
  fi
}


function assert_number {
  local variable="$1"
  local numberExpression='^[0-9]+$'
  if [ -z "$variable" ]; then
    msg_error "Variable asserted to be a number is empty! Aborting.."
    exit 1
  fi
  # Check if the value is a number
  if ! [[ $variable =~ $numberExpression ]] ; then
    msg_error "$variable is not a number! Aborting.."
    exit 1
  fi
}
